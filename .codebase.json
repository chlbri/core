{
  "STATS": {
    "files": 452,
    "imports": 936,
    "exports": 1026
  },
  "CODEBASE_ANALYSIS": {
    "features.arrays.castings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./dynamic",
          "kind": "default",
          "default": "dynamic",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./exclude",
          "kind": "default",
          "default": "fn",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./extract",
          "kind": "default",
          "default": "extract",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./freeze",
          "kind": "default",
          "default": "freeze",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./indexes",
          "kind": "default",
          "default": "indexes",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./length/all",
          "kind": "default",
          "default": "_length",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./low",
          "kind": "default",
          "default": "low",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./reduce",
          "kind": "default",
          "default": "reduce",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./reverse",
          "kind": "default",
          "default": "reverse",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./toArray",
          "kind": "default",
          "default": "toArray",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./tuple/all",
          "kind": "default",
          "default": "tuple",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport dynamic from './dynamic';\nimport fn from './exclude';\nimport extract from './extract';\nimport forceCast from './forceCast';\nimport freeze from './freeze';\nimport _index from './index';\nimport indexes from './indexes';\nimport is from './is';\nimport _length from './length/all';\nimport low from './low';\nimport reduce from './reduce';\nimport reverse from './reverse';\nimport toArray from './toArray';\nimport tuple from './tuple/all';\nimport type from './type';\n\n/**\n * castings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castings = expandFn(_index, {\n  low,\n  is,\n  indexes,\n  _length,\n  tuple,\n  reduce,\n  toArray,\n  reverse,\n  freeze,\n  extract,\n  exclude: fn,\n  forceCast,\n  dynamic,\n  type,\n});\n\n    ",
      "exports": []
    },
    "features.arrays.castings.dynamic": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["AnyArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/dynamic.ts",
      "text": "import type { AnyArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends AnyArray>(value: T) => {\n  return _unknown<T>(value);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.exclude": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["ExcludeArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/exclude.ts",
      "text": "import type { ExcludeArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends any[], const Ex extends T[number][]>(\n  array: T,\n  ...excludes: Ex\n) => {\n  const out = array.filter(item => !excludes.includes(item));\n  return _unknown<ExcludeArray<T, Ex[number]>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.extract": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["ExtractArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/extract.ts",
      "text": "import type { ExtractArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends any[], const Ex extends T[number][]>(\n  array: T,\n  ...extractors: Ex\n) => {\n  const out = array.filter(item => extractors.includes(item));\n  return _unknown<ExtractArray<T, Ex[number]>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/forceCast.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: unknown) => {\n  return _unknown<T[]>(value);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.freeze": {
      "imports": [
        {
          "moduleSpecifier": "./tuple",
          "kind": "default",
          "default": "tuple",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/freeze.ts",
      "text": "import tuple from './tuple';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends any[]>(...args: T) =>\n  Object.freeze(tuple(...args));\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.index": {
      "imports": [],
      "relativePath": "features/arrays/castings/index.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(...values: T[]) => values;\n\nexport default fn;\n",
      "exports": []
    },
    "features.arrays.castings.indexes": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["IndexesOfArray", "RuA", "UnionToTuple"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/indexes.ts",
      "text": "import type { IndexesOfArray, RuA, UnionToTuple } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(...array: T) => {\n  const out = array.map((_, index) => index);\n  return _unknown<UnionToTuple<IndexesOfArray<T>>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.is": {
      "imports": [],
      "relativePath": "features/arrays/castings/is.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: unknown): value is Array<T> => {\n  return Array.isArray(value);\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.arrays.castings.length.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./has",
          "kind": "default",
          "default": "has",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/length/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport has from './has';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, { has });\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.length.has": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["TupleOf"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/length/has.ts",
      "text": "import type { TupleOf } from '../../../../globals/types';\nimport is from '../is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends number>(check: T) => {\n  const _out = (value: unknown): value is TupleOf<unknown, T> => {\n    return is(value) && value.length === check;\n  };\n\n  return _out;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.length.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/length/index.ts",
      "text": "import type { RuA } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends RuA>(...array: T) => {\n  const out = array.length;\n  return _unknown<T['length']>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.low": {
      "imports": [],
      "relativePath": "features/arrays/castings/low.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends unknown[]>(...values: T) => values;\n\nexport default fn;\n",
      "exports": []
    },
    "features.arrays.castings.reduce": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/reduce.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: T | readonly [T] | [T]) => {\n  const out = Array.isArray(value) ? value[0] : value;\n  return _unknown<T>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.reverse": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["ReverseArray", "RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/reverse.ts",
      "text": "import type { ReverseArray, RuA } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends RuA>(...args: T) => {\n  const out = args.slice().reverse();\n  return _unknown<ReverseArray<T>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.toArray": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["ToArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/toArray.ts",
      "text": "import type { ToArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value?: T) => {\n  if (!value) return [];\n  const checkArray = Array.isArray(value);\n  const out = checkArray ? value : [value];\n\n  return _unknown<ToArray<T>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.tuple.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./multiply",
          "kind": "default",
          "default": "multiply",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./permutations/all",
          "kind": "default",
          "default": "permutations",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/tuple/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport is from '../is';\nimport _index from './index';\nimport multiply from './multiply';\nimport permutations from './permutations/all';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  multiply,\n  is,\n  permutations,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.tuple.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/tuple/index.ts",
      "text": "import type { RuA } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(...args: T) => {\n  const out = args;\n  return _unknown<T>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.tuple.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker2"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/tuple/is.ts",
      "text": "import type { Checker2 } from '../../../../globals/types';\nimport is from '../is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T>(fn: Checker2<T>) => {\n  const _out = (value: unknown): value is Array<T> => {\n    return is(value) && value.every(fn);\n  };\n\n  return _out;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.tuple.multiply": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["TupleOf"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/tuple/multiply.ts",
      "text": "import type { TupleOf } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T, N extends number>(data: T, times: N) => {\n  const out = Array.from({ length: times }, () => data);\n  return _unknown<TupleOf<T, N>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.tuple.permutations.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./strict",
          "kind": "default",
          "default": "strict",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/tuple/permutations/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport index from './index';\nimport strict from './strict';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(index, {\n  /**\n   * Génère toutes les permutations possibles d'un tableau d'éléments.\n   * @param arr Le tableau d'éléments à permuter.\n   * @returns Un tableau contenant toutes les permutations possibles.\n   *\n   * **N.B: Sort the array before using this function to prevent unexpected results.**\n   */\n  strict,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.tuple.permutations.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["RuA", "TupleOf"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../multiply",
          "kind": "default",
          "default": "multiply",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/tuple/permutations/index.ts",
      "text": "import type { RuA, TupleOf } from '../../../../../globals/types';\nimport multiply from '../multiply';\n\n/**\n * Génère toutes les permutations possibles d'un tableau d'éléments.\n * @param arr Le tableau d'éléments à permuter.\n * @returns Un tableau contenant toutes les permutations possibles.\n *\n * **N.B: Sort the array before using this function to prevent unexpected results.**\n */\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(\n  ...arr: T\n): TupleOf<T[number], T['length']>[] => {\n  const n = arr.length;\n  if (n < 1) return [];\n  const res: any = [];\n  const used: boolean[] = multiply(false, n);\n  const cur: any = [];\n\n  const backtrack = () => {\n    if (cur.length === n) {\n      res.push([...cur]);\n      return;\n    }\n\n    for (let i = 0; i < n; i++) {\n      if (used[i]) continue;\n      used[i] = true;\n      cur.push(arr[i] as any);\n      backtrack();\n      cur.pop();\n      used[i] = false;\n    }\n  };\n\n  backtrack();\n  return res;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.tuple.permutations.strict": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Permutations", "RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/castings/tuple/permutations/strict.ts",
      "text": "import type { Permutations, RuA } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\nimport index from './index';\n\n/**\n * Génère toutes les permutations possibles d'un tableau d'éléments.\n * @param arr Le tableau d'éléments à permuter.\n * @returns Un tableau contenant toutes les permutations possibles.\n *\n * **N.B: Sort the array before using this function to prevent unexpected results.**\n */\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(...arr: T) => {\n  return _unknown<Permutations<T>[]>(index(...arr));\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.castings.type": {
      "imports": [],
      "relativePath": "features/arrays/castings/type.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = Array;\n\nexport default fn;\n",
      "exports": []
    },
    "features.arrays.index": {
      "imports": [],
      "relativePath": "features/arrays/index.ts",
      "text": "export * from './castings/all';\nexport * from './types';\nexport * from './typings/all';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castings/all';",
          "moduleSpecifier": "./castings/all"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typings/all';",
          "moduleSpecifier": "./typings/all"
        }
      ]
    },
    "features.arrays.types": {
      "imports": [
        {
          "moduleSpecifier": "../../globals/types",
          "kind": "named",
          "namedImports": ["UnionOmit", "UnionToTuple"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/arrays/types.ts",
      "text": "import type { UnionOmit, UnionToTuple } from '../../globals/types';\n\n/**\n * IndexesOfArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type IndexesOfArray<\n  T extends readonly unknown[],\n  S extends number[] = [],\n> = T['length'] extends S['length']\n  ? S[number]\n  : IndexesOfArray<T, [S['length'], ...S]>;\n\n// type _DivideBy<\n//   N extends number,\n//   T extends readonly any[],\n// > = T['length'] extends N\n//   ? [true]\n//   : T extends readonly [...TupleOf<T[number], N>, ...infer U]\n//     ? [true, ..._DivideBy<N, U>]\n//     : never;\n\n// export type DivideTupleLengthBy<\n//   N extends number,\n//   T extends readonly any[],\n// > = _DivideBy<N, T>['length'];\n\ntype _TupleOf<\n  T,\n  N extends number,\n  R extends unknown[] = [],\n> = R['length'] extends N ? R : _TupleOf<T, N, [...R, T]>;\n\n/**\n * TupleOf type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TupleOf<T = any, N extends number = number> = N extends N\n  ? number extends N\n    ? T[]\n    : [..._TupleOf<T, N>]\n  : never;\n\n/**\n * ReverseArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ReverseArray<T extends RuA> = T extends any\n  ? T extends []\n    ? T\n    : T extends [infer Head, ...infer Tail]\n      ? [...ReverseArray<Tail>, Head]\n      : T\n  : never;\n\n/**\n * RuA type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type RuA = readonly unknown[];\n\n/**\n * AnyArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AnyArray<T = unknown> = ReadonlyArray<T> | T[];\n\n/**\n * _NArrayOmit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type _NArrayOmit<\n  T extends readonly object[],\n  K extends keyof T[number] = never,\n> = Extract<UnionOmit<T[number], K>, object>;\n\n/**\n * NArrayOmit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NArrayOmit<\n  T extends readonly object[],\n  K extends keyof T[number] = never,\n> =\n  _NArrayOmit<T, K> extends infer N extends object\n    ? UnionToTuple<N>\n    : never;\n\n/**\n * ExtractArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExtractArray<T extends AnyArray, U> = T extends readonly [\n  infer A,\n  ...infer B,\n]\n  ? A extends U\n    ? [A, ...ExtractArray<B, U>]\n    : [...ExtractArray<B, U>]\n  : [];\n\n/**\n * ExcludeArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExcludeArray<T extends AnyArray, U> = T extends readonly [\n  infer A,\n  ...infer B,\n]\n  ? A extends U\n    ? ExcludeArray<B, U>\n    : [A, ...ExcludeArray<B, U>]\n  : [];\n\n/**\n * ReduceArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ReduceArray<T> = T extends AnyArray ? T[number] : T;\n/**\n * ReduceArrayS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ReduceArrayS<T> = T extends AnyArray ? T[0] : T;\n\n/**\n * ReduceDeepArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ReduceDeepArray<T> =\n  ReduceArray<T> extends AnyArray\n    ? ReduceDeepArray<ReduceArray<T>>\n    : ReduceArray<T>;\n\n/**\n * ToArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ToArray<T> = T extends AnyArray ? T : AnyArray<T>;\n\n/**\n * RecursiveArrayOf type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type RecursiveArrayOf<T> =\n  | Array<_SingleOrRecursiveArrayOf<T>>\n  | ReadonlyArray<_SingleOrRecursiveArrayOf<T>>;\n\ntype _SingleOrRecursiveArrayOf<T> = T | RecursiveArrayOf<T>;\n\n/**\n * Permutations type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Permutations<\n  T extends RuA,\n  I extends IndexesOfArray<T> = IndexesOfArray<T>,\n> = T extends any\n  ? I extends I\n    ? T['length'] extends 0\n      ? []\n      : T['length'] extends 1\n        ? [T[I]]\n        : [\n            T[I],\n            ...Permutations<\n              ExcludeArray<T, T[I]>,\n              IndexesOfArray<ExcludeArray<T, T[I]>>\n            >,\n          ]\n    : never\n  : never;\n\n    ",
      "exports": []
    },
    "features.arrays.typings._length": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/_length.ts",
      "text": "import type { RuA } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(_?: T) => _unknown<T['length']>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./dynamic",
          "kind": "default",
          "default": "dynamic",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./exclude",
          "kind": "default",
          "default": "exclude",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./extract",
          "kind": "default",
          "default": "extract",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./freeze",
          "kind": "default",
          "default": "freeze",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./indexes/all",
          "kind": "default",
          "default": "indexes",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./length",
          "kind": "default",
          "default": "_length",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./low",
          "kind": "default",
          "default": "low",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./reduce/all",
          "kind": "default",
          "default": "reduce",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./reverse",
          "kind": "default",
          "default": "reverse",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./toArray",
          "kind": "default",
          "default": "toArray",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./tuple/all",
          "kind": "default",
          "default": "tuple",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/all.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\nimport dynamic from './dynamic';\nimport exclude from './exclude';\nimport extract from './extract';\nimport forceCast from './forceCast';\nimport freeze from './freeze';\nimport indexes from './indexes/all';\nimport is from './is';\nimport _length from './length';\nimport low from './low';\nimport reduce from './reduce/all';\nimport reverse from './reverse';\nimport toArray from './toArray';\nimport tuple from './tuple/all';\nimport type from './type';\n\n/**\n * typings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typings = typeFn<Array<unknown>>()({\n  low,\n  is,\n  indexes,\n  _length,\n  tuple,\n  reduce,\n  reverse,\n  toArray,\n  freeze,\n  extract,\n  exclude,\n  forceCast,\n  dynamic,\n  type,\n});\n\n    ",
      "exports": []
    },
    "features.arrays.typings.dynamic": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/dynamic.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends unknown[]>(_?: T) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.exclude": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["AnyArray", "ExcludeArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/exclude.ts",
      "text": "import type { AnyArray, ExcludeArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends AnyArray, const U extends T[number][]>(\n  _?: T,\n  ...__: U\n) => _unknown<ExcludeArray<T, U[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.extract": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["AnyArray", "ExtractArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/extract.ts",
      "text": "import type { AnyArray, ExtractArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends AnyArray, const U extends T[number][]>(\n  _?: T,\n  ...__: U\n) => _unknown<ExtractArray<T, U[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/forceCast.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (_?: unknown) => _unknown<unknown[]>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.freeze": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/freeze.ts",
      "text": "import type { RuA } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(..._: T) => _unknown<Readonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["AnyArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/index.ts",
      "text": "import type { AnyArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends AnyArray>(..._: T) => _unknown<T[number][]>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.indexes.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./union",
          "kind": "default",
          "default": "union",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/indexes/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport union from './union';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  union,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.indexes.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["IndexesOfArray", "RuA", "UnionToTuple"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/indexes/index.ts",
      "text": "import type { IndexesOfArray, RuA, UnionToTuple } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(..._: T) =>\n  _unknown<UnionToTuple<IndexesOfArray<T>>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.indexes.union": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["IndexesOfArray", "RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/indexes/union.ts",
      "text": "import type { IndexesOfArray, RuA } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(..._: T) => _unknown<IndexesOfArray<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/is.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_?: T) => _unknown<T extends unknown[] ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.length": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./_length",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/length.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport _index from './_length';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.low": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/low.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(..._: T[]) => _unknown<T[]>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.reduce.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/reduce/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.reduce.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["ReduceDeepArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/reduce/deep.ts",
      "text": "import type { ReduceDeepArray } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_?: T) => _unknown<ReduceDeepArray<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.reduce.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/reduce/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_: T | readonly T[] | T[]) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.reverse": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["ReverseArray", "RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/reverse.ts",
      "text": "import type { ReverseArray, RuA } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends RuA>(..._: T) => _unknown<ReverseArray<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.toArray": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["AnyArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/toArray.ts",
      "text": "import type { AnyArray } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_?: T) => _unknown<AnyArray<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.tuple.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./multiply",
          "kind": "default",
          "default": "multiply",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/tuple/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\nimport multiply from './multiply';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  number: multiply,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.tuple.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/tuple/index.ts",
      "text": "import type { RuA } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends RuA>(..._: T) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.tuple.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/tuple/is.ts",
      "text": "import type { RuA } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T>(_?: T) => _unknown<T extends RuA ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.tuple.multiply": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["TupleOf"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/tuple/multiply.ts",
      "text": "import type { TupleOf } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\nimport { expandFn } from '../../../../globals/utils/expandFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(\n  <const T, N extends number>(_?: T, __?: N) => _unknown<TupleOf<T, N>>(),\n  {\n    is: <const U, N extends number>(_?: U, __?: N) => {\n      const _out = <T>(_?: T) =>\n        _unknown<T extends TupleOf<U, N> ? true : false>();\n      return _out;\n    },\n  },\n);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.arrays.typings.type": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/arrays/typings/type.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = _unknown<unknown[]>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.castings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./false",
          "kind": "default",
          "default": "_false",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./true",
          "kind": "default",
          "default": "_true",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/castings/all.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport _false from './false';\nimport _index from './index';\nimport _true from './true';\nimport type from './type';\n\n/**\n * castings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castings = castFn<boolean>()({\n  is: _index,\n  type,\n  true: _true,\n  false: _false,\n});\n\n    ",
      "exports": []
    },
    "features.booleans.castings.false": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/castings/false.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport { isFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<false>()({\n  CONST: false,\n  is: isFn(false),\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.castings.index": {
      "imports": [],
      "relativePath": "features/booleans/castings/index.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (data: unknown) => typeof data === 'boolean';\n\nexport default fn;\n",
      "exports": []
    },
    "features.booleans.castings.true": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/castings/true.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport { isFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<true>()({\n  CONST: true,\n  is: isFn(true),\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.castings.type": {
      "imports": [],
      "relativePath": "features/booleans/castings/type.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = Boolean;\n\nexport default fn;\n",
      "exports": []
    },
    "features.booleans.index": {
      "imports": [],
      "relativePath": "features/booleans/index.ts",
      "text": "export * from './castings/all';\nexport * from './types';\nexport * from './typings/all';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castings/all';",
          "moduleSpecifier": "./castings/all"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typings/all';",
          "moduleSpecifier": "./typings/all"
        }
      ]
    },
    "features.booleans.types": {
      "imports": [],
      "relativePath": "features/booleans/types.ts",
      "text": "export {};\n",
      "exports": []
    },
    "features.booleans.typings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./false",
          "kind": "default",
          "default": "_false",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./true",
          "kind": "default",
          "default": "_true",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/typings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport _false from './false';\nimport forceCast from './forceCast';\nimport _index from './index';\nimport is from './is';\nimport _true from './true';\nimport type from './type';\n\n/**\n * typings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typings = expandFn(_index, {\n  forceCast,\n  is,\n  type,\n  true: _true,\n  false: _false,\n});\n\n    ",
      "exports": []
    },
    "features.booleans.typings.false": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/typings/false.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<false>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.typings.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/typings/forceCast.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends boolean>(_: unknown) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.typings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/typings/index.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends boolean>(_: T) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.typings.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/typings/is.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_: T) => _unknown<T extends boolean ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.typings.true": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/typings/true.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<true>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.booleans.typings.type": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/booleans/typings/type.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = _unknown<boolean>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings._unknown": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/_unknown.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = _unknown;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./_unknown",
          "kind": "default",
          "default": "_unknown",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./any",
          "kind": "default",
          "default": "any",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./clone",
          "kind": "default",
          "default": "clone",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const",
          "kind": "default",
          "default": "_const",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./date/all",
          "kind": "default",
          "default": "date",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./defaulted/all",
          "kind": "default",
          "default": "defaulted",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./identity",
          "kind": "default",
          "default": "identity",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is/all",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./never",
          "kind": "default",
          "default": "never",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./neverify",
          "kind": "default",
          "default": "neverify",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./null",
          "kind": "default",
          "default": "_null",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./partial/all",
          "kind": "default",
          "default": "partial",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./primitive/all",
          "kind": "default",
          "default": "primitive",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./readonly/all",
          "kind": "default",
          "default": "readonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./required/all",
          "kind": "default",
          "default": "required",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./symbol/all",
          "kind": "default",
          "default": "symbol",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./undefined",
          "kind": "default",
          "default": "_undefined",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./undefiny",
          "kind": "default",
          "default": "undefiny",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport _unknown from './_unknown';\nimport any from './any';\nimport clone from './clone';\nimport _const from './const';\nimport date from './date/all';\nimport defaulted from './defaulted/all';\nimport identity from './identity';\nimport _index from './index';\nimport is from './is/all';\nimport never from './never';\nimport neverify from './neverify';\nimport _null from './null';\nimport partial from './partial/all';\nimport primitive from './primitive/all';\nimport readonly from './readonly/all';\nimport required from './required/all';\nimport symbol from './symbol/all';\nimport _undefined from './undefined';\nimport undefiny from './undefiny';\n\n/**\n * castings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castings = expandFn(_index, {\n  partial,\n  const: _const,\n  identity,\n  clone,\n  unknown: _unknown,\n  neverify,\n  readonly,\n  required,\n  date,\n  primitive,\n  symbol,\n  any,\n  is,\n  null: _null,\n  undefined: _undefined,\n  undefiny,\n  never,\n  defaulted,\n});\n\n    ",
      "exports": []
    },
    "features.common.castings.any": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/any.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<any>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.clone": {
      "imports": [
        {
          "moduleSpecifier": "../../functions/functions/clone",
          "kind": "default",
          "default": "deepClone",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObject"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/common/castings/clone.ts",
      "text": "import deepClone from '../../functions/functions/clone';\nimport type { PrimitiveObject } from '../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends PrimitiveObject>(object: T): T => {\n  return deepClone(object);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.const": {
      "imports": [],
      "relativePath": "features/common/castings/const.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T>(value: T) => value;\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.date.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/date/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.date.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/date/index.ts",
      "text": "import { castFn } from '../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<Date>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.date.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isInstance"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/date/is.ts",
      "text": "import { isInstance } from '../../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = isInstance(Date);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.defaulted.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./runtime",
          "kind": "default",
          "default": "runtime",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./typings",
          "kind": "default",
          "default": "typings",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/defaulted/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport runtime from './runtime';\nimport typings from './typings';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(runtime, { runtime, typings });\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.defaulted.index": {
      "imports": [
        {
          "moduleSpecifier": "./runtime",
          "kind": "default",
          "default": "runtime",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/defaulted/index.ts",
      "text": "import runtime from './runtime';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = runtime;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.defaulted.runtime": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["NonN"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/defaulted/runtime.ts",
      "text": "import type { NonN } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T, U extends NonN<T>>(value: T, defaultValue: U) => {\n  const out = value === undefined || value === null ? defaultValue : value;\n  return _unknown<NonN<T>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.defaulted.typings": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Defaulted", "NonN"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/defaulted/typings.ts",
      "text": "import type { Defaulted, NonN } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T, const U extends NonN<T>>(value: T, defaultValue: U) => {\n  const out = value === undefined || value === null ? defaultValue : value;\n  return _unknown<Defaulted<T, U>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.identity": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/identity",
          "kind": "named",
          "namedImports": ["identity"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/identity.ts",
      "text": "import { identity } from '../../../globals/utils/identity';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = identity;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/index.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<unknown>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.is.all": {
      "imports": [
        {
          "moduleSpecifier": "./defined",
          "kind": "default",
          "default": "defined",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./notDefined",
          "kind": "default",
          "default": "notDefined",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./notNull",
          "kind": "default",
          "default": "notNull",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./notNullish",
          "kind": "default",
          "default": "notNullish",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./notUndefined",
          "kind": "default",
          "default": "notUndefined",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./null",
          "kind": "default",
          "default": "null_",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./nullish",
          "kind": "default",
          "default": "nullish",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./symbol",
          "kind": "default",
          "default": "symbol",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./undefined",
          "kind": "default",
          "default": "undefined_",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/is/all.ts",
      "text": "import defined from './defined';\nimport notDefined from './notDefined';\nimport notNull from './notNull';\nimport notNullish from './notNullish';\nimport notUndefined from './notUndefined';\nimport null_ from './null';\nimport nullish from './nullish';\nimport symbol from './symbol';\nimport undefined_ from './undefined';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = {\n  defined,\n  notDefined,\n  notNull,\n  notNullish,\n  nullish,\n  notUndefined,\n  null: null_,\n  undefined: undefined_,\n  symbol,\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.is.defined": {
      "imports": [],
      "relativePath": "features/common/castings/is/defined.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value?: T): value is NonNullable<T> => {\n  return value !== undefined && value !== null;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.index": {
      "imports": [
        {
          "moduleSpecifier": "./defined",
          "kind": "default",
          "default": "defined",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/is/index.ts",
      "text": "import defined from './defined';\n\nexport default defined;\n\n    ",
      "exports": []
    },
    "features.common.castings.is.notDefined": {
      "imports": [],
      "relativePath": "features/common/castings/is/notDefined.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown) => {\n  return value !== undefined && value !== null;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.notNull": {
      "imports": [],
      "relativePath": "features/common/castings/is/notNull.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown) => {\n  return value !== null;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.notNullish": {
      "imports": [],
      "relativePath": "features/common/castings/is/notNullish.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown) => {\n  return value !== null && value !== undefined;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.notUndefined": {
      "imports": [],
      "relativePath": "features/common/castings/is/notUndefined.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown) => {\n  return value !== undefined;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.null": {
      "imports": [],
      "relativePath": "features/common/castings/is/null.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown): value is null => {\n  return value === null;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.nullish": {
      "imports": [],
      "relativePath": "features/common/castings/is/nullish.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown): value is null | undefined => {\n  return value === null || value === undefined;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.symbol": {
      "imports": [],
      "relativePath": "features/common/castings/is/symbol.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown): value is symbol => {\n  return typeof value === 'symbol';\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.is.undefined": {
      "imports": [],
      "relativePath": "features/common/castings/is/undefined.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown): value is undefined => {\n  return value === undefined;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.never": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isInstance"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/never.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport { isInstance } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<never>()({ is: isInstance(Error) });\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.neverify": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Neverify"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./_unknown",
          "kind": "default",
          "default": "_unknown",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/neverify.ts",
      "text": "import type { Neverify } from '../../../globals/types';\nimport _unknown from './_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: T) => {\n  return _unknown<Neverify<T>>(value);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.null": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/null.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport { isFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<null>()({ is: isFn(null) });\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.partial.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/partial/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.partial.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepPartial"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/partial/deep.ts",
      "text": "import type { DeepPartial } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: T) => {\n  return _unknown<DeepPartial<T>>(value);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.partial.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/partial/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: T) => {\n  return _unknown<Partial<T>>(value);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.primitive.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./object/all",
          "kind": "default",
          "default": "object",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/primitive/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\nimport object from './object/all';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n  object,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.primitive.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Primitive"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/primitive/index.ts",
      "text": "import type { Primitive } from '../../../../globals/types';\nimport { castFn } from '../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<Primitive>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.primitive.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/is/primitive",
          "kind": "named",
          "namedImports": ["isPrimitive"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/primitive/is.ts",
      "text": "import { isPrimitive } from '../../../../globals/utils/is/primitive';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = isPrimitive;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.primitive.object.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/primitive/object/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.primitive.object.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObject"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/primitive/object/index.ts",
      "text": "import type { PrimitiveObject } from '../../../../../globals/types';\nimport { castFn } from '../../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<PrimitiveObject>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.primitive.object.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/is/primitive.object",
          "kind": "named",
          "namedImports": ["isPrimitiveObject"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/primitive/object/is.ts",
      "text": "import { isPrimitiveObject } from '../../../../../globals/utils/is/primitive.object';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = isPrimitiveObject;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.readonly.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/readonly/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep/all';\nimport _index from './index';\nimport not from './not';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n  not,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.readonly.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/readonly/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport not from './not';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  not,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.readonly.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/readonly/deep/index.ts",
      "text": "import type { DeepReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(value: T) =>\n  _unknown<DeepReadonly<T>>(value);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.readonly.deep.not": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepNotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/readonly/deep/not.ts",
      "text": "import type { DeepNotReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object>(value: T) =>\n  _unknown<DeepNotReadonly<T>>(value);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.readonly.index": {
      "imports": [],
      "relativePath": "features/common/castings/readonly/index.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: T) => value as Readonly<T>;\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.castings.readonly.not": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/readonly/not.ts",
      "text": "import type { NotReadonly } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(value: T) => _unknown<NotReadonly<T>>(value);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.required.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/required/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.required.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepRequired"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/required/deep.ts",
      "text": "import type { DeepRequired } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object | undefined>(value: T) => {\n  return _unknown<DeepRequired<T>>(value);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.required.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotUndefined"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/required/index.ts",
      "text": "import type { NotUndefined } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: T) => {\n  return _unknown<NotUndefined<T>>(value);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.symbol.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/symbol/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.symbol.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/symbol/index.ts",
      "text": "import { castFn } from '../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<symbol>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.symbol.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isTypeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/symbol/is.ts",
      "text": "import { isTypeFn } from '../../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = isTypeFn('symbol');\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.undefined": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/castings/undefined.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport { isFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<undefined>()({ is: isFn(undefined) });\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.castings.undefiny": {
      "imports": [],
      "relativePath": "features/common/castings/undefiny.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value?: T) => value;\n\nexport default fn;\n",
      "exports": []
    },
    "features.common.index": {
      "imports": [],
      "relativePath": "features/common/index.ts",
      "text": "export * from './castings/all';\nexport * from './types';\nexport * from './typings/all';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castings/all';",
          "moduleSpecifier": "./castings/all"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typings/all';",
          "moduleSpecifier": "./typings/all"
        }
      ]
    },
    "features.common.types": {
      "imports": [
        {
          "moduleSpecifier": "../transform/types",
          "kind": "named",
          "namedImports": ["TransformS"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../globals/types",
          "kind": "named",
          "namedImports": ["Fn", "RecursiveArrayOf"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/common/types.ts",
      "text": "import type { TransformS } from '../transform/types';\nimport type { Fn, RecursiveArrayOf } from '../../globals/types';\n\n/**\n * SingleOrRecursiveArrayOf type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type SingleOrRecursiveArrayOf<T> = T | RecursiveArrayOf<T>;\n\n/**\n * SoRa type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type SoRa<T> = SingleOrRecursiveArrayOf<T>;\n\n/**\n * Primitive2 type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Primitive2 = string | number | boolean;\n/**\n * Primitive type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Primitive = Primitive2 | undefined | null;\n\n/**\n * SingleOrArray type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type SingleOrArray<T> = T | T[] | ReadonlyArray<T>;\n\n/**\n * SoA type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type SoA<T> = SingleOrArray<T>;\n\n/**\n * PrimitiveObjectMap type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PrimitiveObjectMap = {\n  [key: Keys]: SoRa<_PrimitiveObject>;\n};\n\ntype _PrimitiveObject = Primitive | PrimitiveObjectMap;\n\n/**\n * A type that represents a primitive object, which can be a primitive value or an object\n *\n * @remark\n */\n/**\n * PrimitiveObject type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PrimitiveObject = SoRa<_PrimitiveObject>;\n\n/**\n * NExtract type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NExtract<T, U extends T> = Extract<T, U>;\n/**\n * NExclude type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NExclude<T, U extends T> = Exclude<T, U>;\n\n/**\n * NotUndefined type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NotUndefined<T> = Exclude<T, undefined>;\n\n/**\n * Nu type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Nu<T> = NotUndefined<T>;\n\n/**\n * Undefiny type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Undefiny<T> = T | undefined;\n\n/**\n * Un type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Un<T> = Undefiny<T>;\n\n/**\n * Cast type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Cast<A, B> = A extends B ? A : B;\n\n/**\n * Keys type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Keys = keyof any;\n\n/**\n * TypeStrings type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TypeStrings =\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'bigint'\n  | 'symbol'\n  | 'undefined'\n  | 'object'\n  | 'function';\n\n/**\n * KeyTypes type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type KeyTypes = {\n  [K in Keys]: TypeStrings | Checker2 | KeyTypes;\n};\n\n/**\n * KeyTypesFrom type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type KeyTypesFrom<T extends KeyTypes> = {\n  [K in keyof T]: T[K] extends KeyTypes\n    ? KeyTypesFrom<T[K]>\n    : T[K] extends TypeStrings\n      ? TransformS<T[K]>\n      : T[K] extends Checker2<infer R>\n        ? R\n        : unknown;\n};\n\n/**\n * NonN type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NonN<T> = T extends undefined | null ? any : NonNullable<T>;\n\n/**\n * Defaulted type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Defaulted<T, U extends NonN<T>> = undefined extends T\n  ? U\n  : null extends T\n    ? U\n    : never extends T\n      ? U\n      : T;\n\n// export type Defaulted<T, U extends NonN<T>> = T extends\n//   | undefined\n//   | never\n//   | null\n//   ? U\n//   : T;\n\n/**\n * UnionKeys type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type UnionKeys<U> = U extends Record<infer K, any> ? K : never;\n\n/**\n * _UnionToIntersection1 type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type _UnionToIntersection1<U> = boolean extends U\n  ? U\n  : (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n    ? I\n    : never;\n\n/**\n * _UnionToIntersection2 type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type _UnionToIntersection2<U> = {\n  [K in UnionKeys<U>]: U extends Record<K, infer T> ? T : never;\n};\n\n/**\n * UnionToIntersection type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type UnionToIntersection<U> = _UnionToIntersection2<\n  _UnionToIntersection1<U>\n>;\n\n/**\n * UnionOmit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type UnionOmit<T, K extends Keys> = T extends any\n  ? Omit<T, K>\n  : never;\n\n/**\n * UnionNOmit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type UnionNOmit<T, K extends keyof T> = UnionOmit<T, K>;\n\n/**\n * LastOfUnion type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type LastOfUnion<T> = (\n  (T extends any ? (x: () => T) => void : never) extends (\n    x: infer I,\n  ) => void\n    ? I\n    : never\n) extends () => infer U\n  ? U\n  : never;\n\n/**\n * UnionToTuple type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type UnionToTuple<T, A extends any[] = []> = [T] extends [never]\n  ? A\n  : UnionToTuple<Exclude<T, LastOfUnion<T>>, [LastOfUnion<T>, ...A]>;\n\n// #endregion\n\n/**\n * Checker2 type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Checker2<T = unknown> = (value: unknown) => value is T;\n// | ((value: unknown) => boolean);\n\n/**\n * Equals type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Equals<T, U> = T extends U\n  ? U extends T\n    ? true\n    : false\n  : false;\n\n/**\n * Classe type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Classe = {\n  [Symbol.hasInstance]: Fn<any, boolean>;\n};\n\n    ",
      "exports": []
    },
    "features.common.typings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./any",
          "kind": "default",
          "default": "any",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const",
          "kind": "default",
          "default": "_const",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./date",
          "kind": "default",
          "default": "date",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./defaulted",
          "kind": "default",
          "default": "defaulted",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./exclude/all",
          "kind": "default",
          "default": "exclude",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./extract/all",
          "kind": "default",
          "default": "extract",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./identity",
          "kind": "default",
          "default": "identity",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./keys",
          "kind": "default",
          "default": "keys",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./never",
          "kind": "default",
          "default": "never",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./neverify",
          "kind": "default",
          "default": "neverify",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./null",
          "kind": "default",
          "default": "_null",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./partial/all",
          "kind": "default",
          "default": "partial",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./primitive/all",
          "kind": "default",
          "default": "primitive",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./readonly/all",
          "kind": "default",
          "default": "readonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./required/all",
          "kind": "default",
          "default": "required",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./symbol",
          "kind": "default",
          "default": "symbol",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./undefined",
          "kind": "default",
          "default": "_undefined",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./undefiny",
          "kind": "default",
          "default": "undefiny",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./union",
          "kind": "default",
          "default": "union",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./unknown",
          "kind": "default",
          "default": "unknown",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport any from './any';\nimport _const from './const';\nimport date from './date';\nimport defaulted from './defaulted';\nimport exclude from './exclude/all';\nimport extract from './extract/all';\nimport identity from './identity';\nimport _index from './index';\nimport keys from './keys';\nimport never from './never';\nimport neverify from './neverify';\nimport _null from './null';\nimport partial from './partial/all';\nimport primitive from './primitive/all';\nimport readonly from './readonly/all';\nimport required from './required/all';\nimport symbol from './symbol';\nimport _undefined from './undefined';\nimport undefiny from './undefiny';\nimport union from './union';\nimport unknown from './unknown';\n\n/**\n * typings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typings = expandFn(_index, {\n  partial,\n  const: _const,\n  identity,\n  unknown,\n  neverify,\n  any,\n  required,\n  readonly,\n  primitive,\n  symbol,\n  date,\n  undefiny,\n  extract,\n  exclude,\n  union,\n  null: _null,\n  undefined: _undefined,\n  never,\n  keys,\n  defaulted,\n});\n\n    ",
      "exports": []
    },
    "features.common.typings.any": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/any.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<any>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.const": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/const.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T>(_?: T) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.date": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/date.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Date>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.defaulted": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Defaulted", "NonN"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/defaulted.ts",
      "text": "import type { Defaulted, NonN } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T, U extends NonN<T>>(_?: T, __?: U) =>\n  _unknown<Defaulted<T, U>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.exclude.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const",
          "kind": "default",
          "default": "const_",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "exclude",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/exclude/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport const_ from './const';\nimport exclude from './index';\n\n/**\n * excludeTyping const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst excludeTyping = expandFn(exclude, {\n  const: const_,\n});\n\nexport default excludeTyping;\n\n    ",
      "exports": []
    },
    "features.common.typings.exclude.const": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/exclude/const.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T, const U extends T[]>(_?: T, ...__: U) =>\n  _unknown<Exclude<T, U[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.exclude.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/exclude/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T, U extends any[]>(_?: T, ...__: U) =>\n  _unknown<Exclude<T, U[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.extract.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const",
          "kind": "default",
          "default": "const_",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "extract",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/extract/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport const_ from './const';\nimport extract from './index';\n\n/**\n * extractTyping const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst extractTyping = expandFn(extract, {\n  const: const_,\n});\n\nexport default extractTyping;\n\n    ",
      "exports": []
    },
    "features.common.typings.extract.const": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/extract/const.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T, const U extends T[]>(_?: T, ...__: U) =>\n  _unknown<Extract<T, U[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.extract.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/extract/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T, U extends any[]>(_?: T, ...__: U) =>\n  _unknown<Extract<T, U[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.identity": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/identity.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_?: T) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/index.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<unknown>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.keys": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/keys.ts",
      "text": "import type { Keys } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Keys>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.never": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/never.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<never>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.neverify": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/neverify.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_?: T) => _unknown<T extends never ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.null": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/null.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<null>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.partial.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/partial/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.partial.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepPartial"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/partial/deep.ts",
      "text": "import type { DeepPartial } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<DeepPartial<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.partial.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/partial/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<Partial<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.primitive.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./object",
          "kind": "default",
          "default": "object",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/primitive/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport object from './object';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, { object });\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.primitive.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Primitive"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/primitive/index.ts",
      "text": "import type { Primitive } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Primitive>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.primitive.object": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObject"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/primitive/object.ts",
      "text": "import type { PrimitiveObject } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<PrimitiveObject>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not/all",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep/all';\nimport _index from './index';\nimport is from './is';\nimport not from './not/all';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n  not,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "deepReadonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not/all",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport deepReadonly from './index';\nimport is from './is';\nimport not from './not/all';\n\n/**\n * deep const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst deep = expandFn(deepReadonly, {\n  not,\n  is,\n});\n\nexport default deep;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/deep/index.ts",
      "text": "import type { DeepReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<DeepReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.deep.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/deep/is.ts",
      "text": "import type { DeepReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends DeepReadonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.deep.not.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/deep/not/all.ts",
      "text": "import { expandFn } from '../../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * deepNot const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst deepNot = expandFn(_index, {\n  is,\n});\n\nexport default deepNot;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.deep.not.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepNotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/deep/not/index.ts",
      "text": "import type { DeepNotReadonly } from '../../../../../../globals/types';\nimport { _unknown } from '../../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<DeepNotReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.deep.not.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepNotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/deep/not/is.ts",
      "text": "import type { DeepNotReadonly } from '../../../../../../globals/types';\nimport { _unknown } from '../../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends DeepNotReadonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<Readonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/is.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends Readonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.not.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/not/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * not const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst not = expandFn(_index, {\n  is,\n});\n\nexport default not;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.not.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/not/index.ts",
      "text": "import type { NotReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<NotReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.readonly.not.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/readonly/not/is.ts",
      "text": "import type { NotReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends NotReadonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.required.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "required",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/required/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep';\nimport required from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(required, {\n  deep,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.required.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepRequired"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/required/deep.ts",
      "text": "import type { DeepRequired } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<DeepRequired<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.required.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/required/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<Required<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.required.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/required/is.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_: T) =>\n  _unknown<T extends null | undefined ? false : true>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.symbol": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/symbol.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<symbol>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.undefined": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/undefined.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<undefined>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.undefiny": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/undefiny.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_?: T) => _unknown<T | undefined>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.union": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/union.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends any[]>(..._: T) => _unknown<T[number]>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.common.typings.unknown": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/common/typings/unknown.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<unknown>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.functions.castings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./checker/all",
          "kind": "default",
          "default": "checker",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./dynamic",
          "kind": "default",
          "default": "dynamic",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is/all",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport checker from './checker/all';\nimport dynamic from './dynamic';\nimport forceCast from './forceCast';\nimport _index from './index';\nimport is from './is/all';\n\n/**\n * castings const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst castings = expandFn(_index, {\n  is,\n  forceCast,\n  dynamic,\n  checker,\n});\n\nexport default castings;\n\n    ",
      "exports": []
    },
    "features.functions.castings.checker.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./byType/all",
          "kind": "default",
          "default": "byType",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/checker/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport byType from './byType/all';\nimport forceCast from './forceCast';\nimport _index from './index';\nimport is from './is';\n\n/**\n * checker const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst checker = expandFn(_index, {\n  forceCast,\n  byType,\n  is,\n});\n\nexport default checker;\n\n    ",
      "exports": []
    },
    "features.functions.castings.checker.byType.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./cast",
          "kind": "default",
          "default": "cast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/checker/byType/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport cast from './cast';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  cast,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.functions.castings.checker.byType.cast": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker", "Checker2"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/checker/byType/cast.ts",
      "text": "import type { Checker, Checker2 } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(value: Checker) => _unknown<Checker2<T>>(value);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.functions.castings.checker.byType.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker2"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/functions/castings/checker/byType/index.ts",
      "text": "import type { Checker2 } from '../../../../../globals/types';\n\n/**\n * byType const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst byType = <T>(checker: Checker2<T>) => checker;\n\nexport default byType;\n\n    ",
      "exports": []
    },
    "features.functions.castings.checker.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker", "Checker2"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/checker/forceCast.ts",
      "text": "import type { Checker, Checker2 } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * forceCast const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst forceCast = <T>(value: Checker) => _unknown<Checker2<T>>(value);\n\nexport default forceCast;\n\n    ",
      "exports": []
    },
    "features.functions.castings.checker.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/checker/index.ts",
      "text": "import type { Checker } from '../../../../globals/types';\nimport { castFn } from '../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<Checker>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.functions.castings.checker.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker2"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/functions/castings/checker/is.ts",
      "text": "import type { Checker2 } from '../../../../globals/types';\n\n/**\n * Very low\n * Checks if value is a function with one argument\n * @param value value to check\n * @returns true if value is a function with one argument\n */\n/**\n * is const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst is = <T = unknown>(value: unknown): value is Checker2<T> => {\n  return (\n    typeof value === 'function' &&\n    value.length === 1 &&\n    !/^\\s*class\\s+/.test(value.toString())\n  );\n};\n\nexport default is;\n\n    ",
      "exports": []
    },
    "features.functions.castings.dynamic": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/identity",
          "kind": "named",
          "namedImports": ["identity"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/dynamic.ts",
      "text": "import type { Fn } from '../../../globals/types';\nimport { identity } from '../../../globals/utils/identity';\n\n/**\n * dynamic const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst dynamic = <T extends any[], R = any>(..._: [...T, R]) =>\n  identity<Fn<T, R>>;\n\nexport default dynamic;\n\n    ",
      "exports": []
    },
    "features.functions.castings.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/forceCast.ts",
      "text": "import type { Fn } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * forceCast const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst forceCast = <T extends any[], R = any>(value: unknown) => {\n  return _unknown<Fn<T, R>>(value);\n};\n\nexport default forceCast;\n\n    ",
      "exports": []
    },
    "features.functions.castings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/identity",
          "kind": "named",
          "namedImports": ["identity"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/index.ts",
      "text": "import type { Fn } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\nimport { castFn } from '../../../globals/utils/castFn';\nimport { expandFn } from '../../../globals/utils/expandFn';\nimport { identity } from '../../../globals/utils/identity';\n\n/**\n * castings const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst castings = castFn()({\n  is: expandFn(\n    (value: unknown): value is Fn => {\n      return typeof value === 'function';\n    },\n    {\n      strict: <T extends any[] = any[], R = any>(\n        fn: (value: Fn<T, R>) => boolean,\n      ) => {\n        return (value: unknown): value is Fn<T, R> =>\n          typeof value === 'function' && fn(value as Fn<T, R>);\n      },\n    },\n  ),\n\n  forceCast: <T extends any[], R = any>(value: unknown) => {\n    return _unknown<Fn<T, R>>(value);\n  },\n\n  dynamic: <T extends any[], R = any>(..._: [...T, R]) =>\n    identity<Fn<T, R>>,\n});\n\nexport default castings;\n\n    ",
      "exports": []
    },
    "features.functions.castings.is.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./strict",
          "kind": "default",
          "default": "strict",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings/is/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport strict from './strict';\n\n/**\n * is const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst is = expandFn(_index, {\n  strict,\n});\n\nexport default is;\n\n    ",
      "exports": []
    },
    "features.functions.castings.is.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/functions/castings/is/index.ts",
      "text": "import type { Fn } from '../../../../globals/types';\n\n/**\n * is const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst is = (value: unknown): value is Fn => {\n  return typeof value === 'function';\n};\n\nexport default is;\n\n    ",
      "exports": []
    },
    "features.functions.castings.is.strict": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/functions/castings/is/strict.ts",
      "text": "import type { Fn } from '../../../../globals/types';\n\n/**\n * strict const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst strict = <T extends any[] = any[], R = any>(\n  fn: (value: Fn<T, R>) => boolean,\n) => {\n  return (value: unknown): value is Fn<T, R> =>\n    typeof value === 'function' && fn(value as Fn<T, R>);\n};\n\nexport default strict;\n\n    ",
      "exports": []
    },
    "features.functions.castings": {
      "imports": [
        {
          "moduleSpecifier": "../../globals/types",
          "kind": "named",
          "namedImports": ["Checker", "Checker2", "Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../globals/utils/identity",
          "kind": "named",
          "namedImports": ["identity"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/castings.ts",
      "text": "import type { Checker, Checker2, Fn } from '../../globals/types';\nimport { _unknown } from '../../globals/utils/_unknown';\nimport { castFn } from '../../globals/utils/castFn';\nimport { expandFn } from '../../globals/utils/expandFn';\nimport { identity } from '../../globals/utils/identity';\n\n/**\n * castings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castings = castFn()({\n  is: expandFn(\n    (value: unknown): value is Fn => {\n      return typeof value === 'function';\n    },\n    {\n      strict: <T extends any[] = any[], R = any>(\n        fn: Checker<Fn<T, R>>,\n      ) => {\n        return (value: unknown): value is Fn<T, R> =>\n          typeof value === 'function' && fn(value);\n      },\n    },\n  ),\n\n  forceCast: <T extends any[], R = any>(value: unknown) => {\n    return _unknown<Fn<T, R>>(value);\n  },\n\n  dynamic: <T extends any[], R = any>(..._: [...T, R]) =>\n    identity<Fn<T, R>>,\n\n  checker: castFn<Checker>()({\n    /**\n     * Very low\n     * Checks if value is a function with one argument\n     * @param value value to check\n     * @returns true if value is a function with one argument\n     */\n    is: <T = unknown>(value: unknown): value is Checker2<T> => {\n      return (\n        typeof value === 'function' &&\n        value.length === 1 &&\n        !/^\\s*class\\s+/.test(value.toString())\n      );\n    },\n\n    byType: expandFn(<T>(checker: Checker2<T>) => checker, {\n      forceCast: <T>(value: Checker) => _unknown<Checker2<T>>(value),\n    }),\n  }),\n});\n\n    ",
      "exports": []
    },
    "features.functions.functions.clone": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObject"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/functions/functions/clone.ts",
      "text": "import type { PrimitiveObject } from '../../../globals/types';\n\n/**\n * FormatKey type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type FormatKey<T = any> = (key: Extract<keyof T, string>) => string;\n\n/**\n * Creates a deep clone of an object or array, preserving its structure and values.\n *\n *\n * @param value of type {@linkcode PrimitiveObject} The value to deep clone, which can be an object, array, or primitive.\n * @param formatKey A function to format the keys of the cloned object. If not provided, keys will remain unchanged.\n * @param refs A map to keep track of already cloned objects to handle circular references.\n * This is used to prevent infinite loops when cloning objects that reference each other.\n * @returns A deep clone of the input value, preserving the structure and values of the original object or array.\n *\n * Inspired by the \"deep-clone\" npm {@link https://www.npmjs.com/package/deep-clone|library},\n * @see the {@link https://github.com/thebearingedge/deep-clone/blob/main/src/deep-clone.ts|implementation} for more details.\n */\n/**\n * default function - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport default function deepClone<I extends PrimitiveObject>(\n  value: I,\n  refs = new Map<I, I>(),\n): I {\n  const ref = refs.get(value);\n  if (typeof ref !== 'undefined') return ref;\n\n  if (Array.isArray(value)) {\n    const clone: any = [];\n    refs.set(value, clone);\n\n    for (let i = 0; i < value.length; i++) {\n      clone[i] = deepClone(value[i], refs as any);\n    }\n\n    return clone as I;\n  }\n\n  if (!(value instanceof Object)) return value as unknown as I;\n\n  const clone: Record<string, PrimitiveObject> = {};\n  refs.set(value, clone as I);\n  const keys = Object.keys(value);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    clone[key] = deepClone((value as any)[keys[i]], refs);\n  }\n\n  if (Object.isFrozen(value)) {\n    Object.freeze(clone);\n  }\n\n  if (Object.isSealed(value)) {\n    Object.seal(clone);\n  }\n\n  return clone as I;\n}\n\n    ",
      "exports": []
    },
    "features.functions.functions.index": {
      "imports": [],
      "relativePath": "features/functions/functions/index.ts",
      "text": "export * from './clone';\nexport * from './partialCall';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './clone';",
          "moduleSpecifier": "./clone"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './partialCall';",
          "moduleSpecifier": "./partialCall"
        }
      ]
    },
    "features.functions.functions.partialCall": {
      "imports": [
        {
          "moduleSpecifier": "../../arrays/types",
          "kind": "named",
          "namedImports": ["AnyArray"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/functions/functions/partialCall.ts",
      "text": "import type { AnyArray } from '../../arrays/types';\nimport type { Fn } from '../types';\n\ntype PartialCall_F = <\n  T extends AnyArray = AnyArray,\n  U extends AnyArray = AnyArray,\n  R = any,\n>(\n  f: Fn<[...T, ...U], R>,\n  ...headArgs: T\n) => (...tailArgs: U) => R;\n\n/**\n * partialCall variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const partialCall: PartialCall_F = (f, ...headArgs) => {\n  return (...tailArgs) => f(...headArgs, ...tailArgs);\n};\n\n    ",
      "exports": []
    },
    "features.functions.index": {
      "imports": [],
      "relativePath": "features/functions/index.ts",
      "text": "export * from './castings';\nexport * as functions from './functions';\nexport * from './types';\nexport * from './typings';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castings';",
          "moduleSpecifier": "./castings"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as functions from './functions';",
          "moduleSpecifier": "./functions"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typings';",
          "moduleSpecifier": "./typings"
        }
      ]
    },
    "features.functions.types": {
      "imports": [],
      "relativePath": "features/functions/types.ts",
      "text": "/**\n * Fn type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Fn<Args extends any[] = any[], R = any> = (...args: Args) => R;\n\n/**\n * FnBasic type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type FnBasic<Main extends Fn, Tr extends object> = Tr & Main;\n\n/**\n * Checker type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Checker<T = unknown> =\n  | ((value: unknown) => value is T)\n  | Fn<[unknown], boolean>;\n",
      "exports": []
    },
    "features.functions.typings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./checker/all",
          "kind": "default",
          "default": "checker",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./dynamic",
          "kind": "default",
          "default": "dynamic",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport checker from './checker/all';\nimport dynamic from './dynamic';\nimport forceCast from './forceCast';\nimport _index from './index';\n\n/**\n * typings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typings = expandFn(_index, {\n  dynamic,\n  forceCast,\n  checker,\n});\n\n    ",
      "exports": []
    },
    "features.functions.typings.checker.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./byType/all",
          "kind": "default",
          "default": "byType",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/checker/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport byType from './byType/all';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  byType,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.functions.typings.checker.byType.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./cast",
          "kind": "default",
          "default": "cast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/checker/byType/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport cast from './cast';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  cast,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.functions.typings.checker.byType.cast": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker", "Checker2"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/checker/byType/cast.ts",
      "text": "import type { Checker, Checker2 } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(_?: Checker) => _unknown<Checker2<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.functions.typings.checker.byType.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker2"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/checker/byType/index.ts",
      "text": "import type { Checker2 } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * byType const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst byType = <T>(_?: Checker2<T>) => _unknown<Checker2<T>>();\n\nexport default byType;\n\n    ",
      "exports": []
    },
    "features.functions.typings.checker.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Checker"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/checker/index.ts",
      "text": "import type { Checker } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\n\n/**\n * checker const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst checker = typeFn<Checker>()();\n\nexport default checker;\n\n    ",
      "exports": []
    },
    "features.functions.typings.dynamic": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/dynamic.ts",
      "text": "import type { Fn } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * dynamic const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst dynamic = <T extends any[], R = any>(..._: [...T, R]) =>\n  _unknown<Fn<T, R>>();\n\nexport default dynamic;\n\n    ",
      "exports": []
    },
    "features.functions.typings.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/forceCast.ts",
      "text": "import type { Fn } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * forceCast const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst forceCast = <T extends any[], R = any>(_?: unknown) => {\n  return _unknown<Fn<T, R>>();\n};\n\nexport default forceCast;\n\n    ",
      "exports": []
    },
    "features.functions.typings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/functions/typings/index.ts",
      "text": "import type { Fn } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * typings const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst typings = typeFn<Fn>()({\n  dynamic: <T extends any[], R = any>(..._: [...T, R]) =>\n    _unknown<Fn<T, R>>(),\n\n  forceCast: <T extends any[], R = any>(_?: unknown) => {\n    return _unknown<Fn<T, R>>();\n  },\n});\n\nexport default typings;\n\n    ",
      "exports": []
    },
    "features.functions.typings": {
      "imports": [],
      "relativePath": "features/functions/typings.ts",
      "text": "export { typings } from './typings/all';\n",
      "exports": [
        {
          "name": "typings",
          "kind": "named",
          "text": "export { typings } from './typings/all';",
          "moduleSpecifier": "./typings/all"
        }
      ]
    },
    "features.index": {
      "imports": [],
      "relativePath": "features/index.ts",
      "text": "export * as arrays from './arrays';\nexport * as booleans from './booleans';\nexport * as common from './common';\nexport * as functions from './functions';\nexport * as numbers from './numbers';\nexport * as objects from './objects';\nexport * as promises from './promises';\nexport * as strings from './strings';\nexport * as transformers from './transform';\nexport * as typescript from './typescript';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as arrays from './arrays';",
          "moduleSpecifier": "./arrays"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as booleans from './booleans';",
          "moduleSpecifier": "./booleans"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as common from './common';",
          "moduleSpecifier": "./common"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as functions from './functions';",
          "moduleSpecifier": "./functions"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as numbers from './numbers';",
          "moduleSpecifier": "./numbers"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as objects from './objects';",
          "moduleSpecifier": "./objects"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as promises from './promises';",
          "moduleSpecifier": "./promises"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as strings from './strings';",
          "moduleSpecifier": "./strings"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as transformers from './transform';",
          "moduleSpecifier": "./transform"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as typescript from './typescript';",
          "moduleSpecifier": "./typescript"
        }
      ]
    },
    "features.numbers.castings.MINUS_1": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/identity",
          "kind": "named",
          "namedImports": ["identity"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/MINUS_1.ts",
      "text": "import { identity } from '../../../globals/utils/identity';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = identity(-1);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.castings.ONE": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/identity",
          "kind": "named",
          "namedImports": ["identity"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/ONE.ts",
      "text": "import { identity } from '../../../globals/utils/identity';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = identity(1);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.castings.ZERO": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/identity",
          "kind": "named",
          "namedImports": ["identity"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/ZERO.ts",
      "text": "import { identity } from '../../../globals/utils/identity';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = identity(0);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.castings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./bigint",
          "kind": "default",
          "default": "bigint",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./digit",
          "kind": "default",
          "default": "digit",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./getString",
          "kind": "default",
          "default": "getString",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./MINUS_1",
          "kind": "default",
          "default": "MINUS_1",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ONE",
          "kind": "default",
          "default": "ONE",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ZERO",
          "kind": "default",
          "default": "ZERO",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport bigint from './bigint';\nimport digit from './digit';\nimport getString from './getString';\nimport _index from './index';\nimport is from './is';\nimport MINUS_1 from './MINUS_1';\nimport ONE from './ONE';\nimport type from './type';\nimport ZERO from './ZERO';\n\n/**\n * castings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castings = expandFn(_index, {\n  is,\n  getString,\n  digit,\n  type,\n  ZERO,\n  ONE,\n  MINUS_1,\n  bigint,\n});\n\n    ",
      "exports": []
    },
    "features.numbers.castings.bigint": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isTypeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/bigint.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport { isTypeFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<bigint>()({\n  is: isTypeFn('bigint'),\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.castings.digit": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": ["DIGITS"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/digit.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\nimport { DIGITS } from '../constants';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn.withValues(...DIGITS);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.castings.getString": {
      "imports": [],
      "relativePath": "features/numbers/castings/getString.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends number | string>(arg: T): `${T}` => `${arg}`;\n\nexport default fn;\n",
      "exports": []
    },
    "features.numbers.castings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/index.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<number>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.castings.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isTypeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/castings/is.ts",
      "text": "import { isTypeFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = isTypeFn('number');\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.castings.type": {
      "imports": [],
      "relativePath": "features/numbers/castings/type.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = Number;\n\nexport default fn;\n",
      "exports": []
    },
    "features.numbers.constants": {
      "imports": [],
      "relativePath": "features/numbers/constants.ts",
      "text": "/**\n * DIGITS variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const DIGITS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] as const;\n",
      "exports": []
    },
    "features.numbers.index": {
      "imports": [],
      "relativePath": "features/numbers/index.ts",
      "text": "export * from './castings/all';\nexport * from './overload';\nexport * from './types';\nexport * from './typings/all';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castings/all';",
          "moduleSpecifier": "./castings/all"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './overload';",
          "moduleSpecifier": "./overload"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typings/all';",
          "moduleSpecifier": "./typings/all"
        }
      ]
    },
    "features.numbers.overload.index": {
      "imports": [],
      "relativePath": "features/numbers/overload/index.ts",
      "text": "export * from './percent';\nexport * from './percentS';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './percent';",
          "moduleSpecifier": "./percent"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './percentS';",
          "moduleSpecifier": "./percentS"
        }
      ]
    },
    "features.numbers.overload.percent": {
      "imports": [],
      "relativePath": "features/numbers/overload/percent.ts",
      "text": "export {};\n\ndeclare global {\n  interface Number {\n    /**\n     * **N.B : Call this the file \"src/features/numbers/overload/percent.ts\"**\n     *\n     * @returns the percent value of the number (e.g., 10.percent = 0.1)\n     */\n    get percent(): number;\n  }\n}\n\nObject.defineProperty(Number.prototype, 'percent', {\n  get: function () {\n    return this.valueOf() / 100;\n  },\n  configurable: false,\n  enumerable: false,\n});\n",
      "exports": []
    },
    "features.numbers.overload.percentS": {
      "imports": [],
      "relativePath": "features/numbers/overload/percentS.ts",
      "text": "export {};\n\ndeclare global {\n  interface Number {\n    /**\n     * **N.B : Call this the file \"src/features/numbers/overload/percentS.ts\"**\n     *\n     * @returns the percent value of the number as a string (e.g., 10.percentS = \"10%\")\n     */\n    get percentS(): string;\n  }\n}\n\nObject.defineProperty(Number.prototype, 'percentS', {\n  get: function () {\n    return `${this.toString()}%`;\n  },\n  configurable: false,\n  enumerable: false,\n});\n",
      "exports": []
    },
    "features.numbers.types": {
      "imports": [
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": ["DIGITS"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/numbers/types.ts",
      "text": "import type { DIGITS } from './constants';\n\n/**\n * ToString type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ToString<T extends number | string> = `${T}`;\n\n/**\n * Digit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Digit = (typeof DIGITS)[number];\n\n    ",
      "exports": []
    },
    "features.numbers.typings.MINUS_1": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/MINUS_1.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = () => _unknown<-1>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.typings.ONE": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/ONE.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = () => _unknown<1>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.typings.ZERO": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/ZERO.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = () => _unknown<0>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.typings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./bigint",
          "kind": "default",
          "default": "bigint",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./digit",
          "kind": "default",
          "default": "digit",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./getString",
          "kind": "default",
          "default": "getString",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./MINUS_1",
          "kind": "default",
          "default": "MINUS_1",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ONE",
          "kind": "default",
          "default": "ONE",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ZERO",
          "kind": "default",
          "default": "ZERO",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport bigint from './bigint';\nimport digit from './digit';\nimport getString from './getString';\nimport _index from './index';\nimport MINUS_1 from './MINUS_1';\nimport ONE from './ONE';\nimport ZERO from './ZERO';\n\n/**\n * typings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typings = expandFn(_index, {\n  getString,\n  digit,\n  ZERO,\n  ONE,\n  MINUS_1,\n  bigint,\n});\n\n    ",
      "exports": []
    },
    "features.numbers.typings.bigint": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/bigint.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<bigint>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.typings.digit": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Digit"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/digit.ts",
      "text": "import type { Digit } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Digit>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.typings.getString": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/getString.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends number>(_: T) => _unknown<`${T}`>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.numbers.typings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/numbers/typings/index.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<number>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./byKey",
          "kind": "default",
          "default": "byKey",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./entries",
          "kind": "default",
          "default": "entries",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./freeze/all",
          "kind": "default",
          "default": "freeze",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./hasKeys/all",
          "kind": "default",
          "default": "hasKeys",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./keyTypes/all",
          "kind": "default",
          "default": "keyTypes",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./keysOf",
          "kind": "default",
          "default": "keys",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./omit/all",
          "kind": "default",
          "default": "omit",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./pick/all",
          "kind": "default",
          "default": "pick",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./primitive",
          "kind": "default",
          "default": "primitive",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ra",
          "kind": "default",
          "default": "ra",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./readonly/all",
          "kind": "default",
          "default": "readonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./require/all",
          "kind": "default",
          "default": "require",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./reverse",
          "kind": "default",
          "default": "reverse",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ru",
          "kind": "default",
          "default": "ru",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./trueObject",
          "kind": "default",
          "default": "trueObject",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./values",
          "kind": "default",
          "default": "values",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./noExtra",
          "kind": "default",
          "default": "noExtra",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport byKey from './byKey';\nimport entries from './entries';\nimport freeze from './freeze/all';\nimport hasKeys from './hasKeys/all';\nimport _index from './index';\nimport keyTypes from './keyTypes/all';\nimport keys from './keysOf';\nimport omit from './omit/all';\nimport pick from './pick/all';\nimport primitive from './primitive';\nimport ra from './ra';\nimport readonly from './readonly/all';\nimport require from './require/all';\nimport reverse from './reverse';\nimport ru from './ru';\nimport trueObject from './trueObject';\nimport type from './type';\nimport values from './values';\nimport noExtra from './noExtra';\n\n/**\n * castings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castings = expandFn(_index, {\n  trueObject,\n  type,\n  keys,\n  values,\n  entries,\n  byKey,\n  hasKeys,\n  keyTypes,\n  omit,\n  reverse,\n  readonly,\n  freeze,\n  require,\n  pick,\n  ru,\n  ra,\n  primitive,\n  noExtra,\n});\n\n    ",
      "exports": []
    },
    "features.objects.castings.byKey": {
      "imports": [],
      "relativePath": "features/objects/castings/byKey.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n): T[K] => {\n  return object[key];\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.entries": {
      "imports": [],
      "relativePath": "features/objects/castings/entries.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T): [keyof T, T[keyof T]][] => {\n  return Object.entries(object) as any;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.freeze.all": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/all.ts",
      "text": "export { default } from '#features/objects/castings/readonly/all';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/all';",
          "moduleSpecifier": "#features/objects/castings/readonly/all"
        }
      ]
    },
    "features.objects.castings.freeze.deep.all": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/deep/all.ts",
      "text": "export { default } from '#features/objects/castings/readonly/deep/all';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/deep/all';",
          "moduleSpecifier": "#features/objects/castings/readonly/deep/all"
        }
      ]
    },
    "features.objects.castings.freeze.deep.index": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/deep/index.ts",
      "text": "export { default } from '#features/objects/castings/readonly/deep/index';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/deep/index';",
          "moduleSpecifier": "#features/objects/castings/readonly/deep/index"
        }
      ]
    },
    "features.objects.castings.freeze.deep.not": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/deep/not.ts",
      "text": "export { default } from '#features/objects/castings/readonly/deep/not';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/deep/not';",
          "moduleSpecifier": "#features/objects/castings/readonly/deep/not"
        }
      ]
    },
    "features.objects.castings.freeze.dynamic": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/dynamic.ts",
      "text": "export { default } from '#features/objects/castings/readonly/dynamic';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/dynamic';",
          "moduleSpecifier": "#features/objects/castings/readonly/dynamic"
        }
      ]
    },
    "features.objects.castings.freeze.forceCast": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/forceCast.ts",
      "text": "export { default } from '#features/objects/castings/readonly/forceCast';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/forceCast';",
          "moduleSpecifier": "#features/objects/castings/readonly/forceCast"
        }
      ]
    },
    "features.objects.castings.freeze.index": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/index.ts",
      "text": "export { default } from '#features/objects/castings/readonly/index';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/index';",
          "moduleSpecifier": "#features/objects/castings/readonly/index"
        }
      ]
    },
    "features.objects.castings.freeze.is": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/is.ts",
      "text": "export { default } from '#features/objects/castings/readonly/is';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/is';",
          "moduleSpecifier": "#features/objects/castings/readonly/is"
        }
      ]
    },
    "features.objects.castings.freeze.not": {
      "imports": [],
      "relativePath": "features/objects/castings/freeze/not.ts",
      "text": "export { default } from '#features/objects/castings/readonly/not';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default } from '#features/objects/castings/readonly/not';",
          "moduleSpecifier": "#features/objects/castings/readonly/not"
        }
      ]
    },
    "features.objects.castings.hasKeys._all.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./typings",
          "kind": "default",
          "default": "typings",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/hasKeys/_all/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport typings from './typings';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  typings,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.hasKeys._all.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/hasKeys/_all/index.ts",
      "text": "import type { Keys } from '../../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <K extends Keys[]>(\n  object: object,\n  ...keys: K\n): object is Record<K[number], unknown> => {\n  return (\n    Object.keys(object).every(key => keys.includes(key)) &&\n    keys.every(key => key in object)\n  );\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.hasKeys._all.typings": {
      "imports": [
        {
          "moduleSpecifier": "../../../utils/entries",
          "kind": "named",
          "namedImports": ["checkEntries"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes", "KeyTypesFrom"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/hasKeys/_all/typings.ts",
      "text": "import { checkEntries } from '../../../utils/entries';\nimport type { KeyTypes, KeyTypesFrom } from '../../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <K extends KeyTypes>(\n  object: object,\n  keys: K,\n): object is KeyTypesFrom<K> => {\n  const check0 =\n    Object.keys(object).every(key => key in keys) &&\n    Object.keys(keys).every(key => key in object);\n\n  if (!check0) return false;\n\n  return checkEntries(keys, object);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.hasKeys.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./_all/all",
          "kind": "default",
          "default": "all",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./typings",
          "kind": "default",
          "default": "typings",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/hasKeys/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport all from './_all/all';\nimport _index from './index';\nimport typings from './typings';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  typings,\n  all,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.hasKeys.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/hasKeys/index.ts",
      "text": "import type { Keys } from '../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <K extends Keys[]>(\n  object: object,\n  ...keys: K\n): object is Record<K[number], unknown> => {\n  return keys.every(key => key in object);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.hasKeys.typings": {
      "imports": [
        {
          "moduleSpecifier": "../../utils/entries",
          "kind": "named",
          "namedImports": ["checkEntries"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes", "KeyTypesFrom"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/hasKeys/typings.ts",
      "text": "import { checkEntries } from '../../utils/entries';\nimport type { KeyTypes, KeyTypesFrom } from '../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <K extends KeyTypes>(\n  object: object,\n  keys: K,\n): object is KeyTypesFrom<K> => {\n  return checkEntries(keys, object);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/index.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<object>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.keyTypes.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./from",
          "kind": "default",
          "default": "from",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/keyTypes/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport from from './from';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  from,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.keyTypes.from": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes", "KeyTypesFrom"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/keyTypes/from.ts",
      "text": "import type { KeyTypes, KeyTypesFrom } from '../../../../globals/types';\nimport { castFn } from '../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends KeyTypes>(keyType: T) => {\n  return castFn<KeyTypesFrom<T>>()({\n    is: (value: unknown): value is KeyTypesFrom<T> => {\n      return typeof value === (keyType as unknown as string);\n    },\n  });\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.keyTypes.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/keyTypes/index.ts",
      "text": "import type { KeyTypes } from '../../../../globals/types';\nimport { castFn } from '../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<KeyTypes>()({});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.keyTypes.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/is/object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/keyTypes/is.ts",
      "text": "import type { KeyTypes } from '../../../../globals/types';\nimport { isPlainObject } from '../../../../globals/utils/is/object';\n\n/**\n * is const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst is = (value: unknown): value is KeyTypes => {\n  const isObject = isPlainObject(value);\n  if (!isObject) return false;\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'symbol'\n  );\n};\n\nexport default is;\n\n    ",
      "exports": []
    },
    "features.objects.castings.keysOf": {
      "imports": [],
      "relativePath": "features/objects/castings/keysOf.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T): (keyof T)[] => {\n  return Object.keys(object) as any;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.noExtra": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["NoExtraKeysStrict"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/noExtra.ts",
      "text": "import type { NoExtraKeysStrict } from '../../../globals/types';\n\ntype P<T> = NoExtraKeysStrict<T, T>;\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <Schema>(_?: Schema) => {\n  return <T extends P<Schema>>(value: T) => value;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./by/all",
          "kind": "default",
          "default": "by",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const/all",
          "kind": "default",
          "default": "_const",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./strict/all",
          "kind": "default",
          "default": "strict",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport by from './by/all';\nimport _const from './const/all';\nimport deep from './deep/all';\nimport _index from './index';\nimport is from './is';\nimport strict from './strict/all';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  strict,\n  const: _const,\n  is,\n  by,\n  deep,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.by.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/by/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.by.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["SubType"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../utils/omit",
          "kind": "named",
          "namedImports": ["omit"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/by/index.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport type { SubType } from '../../../../../globals/types';\nimport { omit } from '../../../utils/omit';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omit, 'element') as <\n  T extends object,\n  K extends any[],\n>(\n  object: T,\n  ...values: K\n) => SubType<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.by.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/omit.is",
          "kind": "named",
          "namedImports": ["omitIs"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/by/is.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { omitIs } from '../../../utils/omit.is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitIs, 'element');\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.const.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/const/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.const.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/omit",
          "kind": "named",
          "namedImports": ["omit"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/const/index.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { omit } from '../../../utils/omit';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omit, 'key') as <\n  const T extends object,\n  K extends (keyof T)[],\n>(\n  object: T,\n  ...keys: K\n) => Omit<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.const.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/omit.is",
          "kind": "named",
          "namedImports": ["omitIs"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/const/is.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { omitIs } from '../../../utils/omit.is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitIs, 'key') as <\n  const T extends object,\n  K extends (keyof T)[],\n>(\n  object: T,\n  ...keys: K\n) => boolean;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./by/all",
          "kind": "default",
          "default": "by",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport by from './by/all';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  by,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.deep.by.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/deep/by/all.ts",
      "text": "import { expandFn } from '../../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.deep.by.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys", "NotSubType", "PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../utils/omit.deep",
          "kind": "named",
          "namedImports": ["omitDeep"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/deep/by/index.ts",
      "text": "import { partialCall } from '../../../../../functions/functions/partialCall';\nimport type { Keys, NotSubType, PrimitiveObjectMap } from '../../../../../../globals/types';\nimport { omitDeep } from '../../../../utils/omit.deep';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitDeep, 'element') as <\n  T extends PrimitiveObjectMap,\n  K extends Keys[],\n>(\n  object: T,\n  ...values: K\n) => NotSubType<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.deep.by.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../utils/omit.deep.is",
          "kind": "named",
          "namedImports": ["omitDeepIs"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/deep/by/is.ts",
      "text": "import { partialCall } from '../../../../../functions/functions/partialCall';\nimport { omitDeepIs } from '../../../../utils/omit.deep.is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitDeepIs, 'element');\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepOmit", "Keys", "PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../utils/omit.deep",
          "kind": "named",
          "namedImports": ["omitDeep"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/deep/index.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport type { DeepOmit, Keys, PrimitiveObjectMap } from '../../../../../globals/types';\nimport { omitDeep } from '../../../utils/omit.deep';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitDeep, 'key') as <\n  T extends PrimitiveObjectMap,\n  K extends Keys[],\n>(\n  object: T,\n  ...keys: K\n) => DeepOmit<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.deep.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/omit.deep.is",
          "kind": "named",
          "namedImports": ["omitDeepIs"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys", "PrimitiveObjectMap"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/omit/deep/is.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { omitDeepIs } from '../../../utils/omit.deep.is';\nimport type { Keys, PrimitiveObjectMap } from '../../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitDeepIs, 'key') as (\n  object: PrimitiveObjectMap,\n  ...keys: Keys[]\n) => boolean;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../utils/omit",
          "kind": "named",
          "namedImports": ["omit"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/index.ts",
      "text": "import { partialCall } from '../../../functions/functions/partialCall';\nimport type { PrimitiveObjectMap } from '../../../../globals/types';\nimport { omit } from '../../utils/omit';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omit, 'key') as <\n  T extends PrimitiveObjectMap,\n  K extends any[],\n>(\n  object: T,\n  ...keys: K\n) => Omit<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../utils/omit.is",
          "kind": "named",
          "namedImports": ["omitIs"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys", "PrimitiveObjectMap"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/omit/is.ts",
      "text": "import { partialCall } from '../../../functions/functions/partialCall';\nimport { omitIs } from '../../utils/omit.is';\nimport type { Keys, PrimitiveObjectMap } from '../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitIs, 'key') as <K extends Keys[]>(\n  object: PrimitiveObjectMap,\n  ...keys: K\n) => boolean;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.strict.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/strict/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.strict.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/omit",
          "kind": "named",
          "namedImports": ["omit"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/strict/index.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { omit } from '../../../utils/omit';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omit, 'key') as <\n  T extends object,\n  K extends (keyof T)[],\n>(\n  object: T,\n  ...keys: K\n) => Omit<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.omit.strict.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/omit.is",
          "kind": "named",
          "namedImports": ["omitIs"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/omit/strict/is.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { omitIs } from '../../../utils/omit.is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(omitIs, 'key') as <\n  T extends object,\n  K extends (keyof T)[],\n>(\n  object: T,\n  ...keys: K\n) => boolean;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.pick.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./by",
          "kind": "default",
          "default": "by",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/pick/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport by from './by';\nimport deep from './deep/all';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n  by,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.pick.by": {
      "imports": [
        {
          "moduleSpecifier": "../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["SubType"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../utils/pick",
          "kind": "named",
          "namedImports": ["pick"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/pick/by.ts",
      "text": "import { partialCall } from '../../../functions/functions/partialCall';\nimport type { SubType } from '../../../../globals/types';\nimport { pick } from '../../utils/pick';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(pick, 'element') as <\n  T extends object,\n  K extends any[],\n>(\n  object: T,\n  ...keys: K\n) => SubType<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.pick.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./by",
          "kind": "default",
          "default": "by",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/pick/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport by from './by';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  by,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.pick.deep.by": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/pick.deep",
          "kind": "named",
          "namedImports": ["pickDeep"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/pick/deep/by.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { pickDeep } from '../../../utils/pick.deep';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(pickDeep, 'element');\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.pick.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../utils/pick.deep",
          "kind": "named",
          "namedImports": ["pickDeep"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/pick/deep/index.ts",
      "text": "import { partialCall } from '../../../../functions/functions/partialCall';\nimport { pickDeep } from '../../../utils/pick.deep';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(pickDeep, 'key');\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.pick.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../functions/functions/partialCall",
          "kind": "named",
          "namedImports": ["partialCall"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../utils/pick",
          "kind": "named",
          "namedImports": ["pick"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/pick/index.ts",
      "text": "import { partialCall } from '../../../functions/functions/partialCall';\nimport { pick } from '../../utils/pick';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = partialCall(pick, 'key') as <T extends object, K extends any[]>(\n  object: T,\n  ...keys: K\n) => Pick<T, K[number]>;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.primitive": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/primitive.object",
          "kind": "named",
          "namedImports": ["isPrimitiveObject"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/primitive.ts",
      "text": "import type { PrimitiveObjectMap } from '../../../globals/types';\nimport { castFn } from '../../../globals/utils/castFn';\nimport { isPlainObject } from '../../../globals/utils/is/object';\nimport { isPrimitiveObject } from '../../../globals/utils/is/primitive.object';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<PrimitiveObjectMap>()({\n  is: (object: unknown): object is PrimitiveObjectMap => {\n    if (!isPlainObject(object)) return false;\n    return isPrimitiveObject(object);\n  },\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.ra": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Ra"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/ra.ts",
      "text": "import type { Ra } from '../../../globals/types';\nimport { castFn } from '../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<Ra>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.readonly.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./dynamic",
          "kind": "default",
          "default": "dynamic",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/readonly/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep/all';\nimport dynamic from './dynamic';\nimport forceCast from './forceCast';\nimport _index from './index';\nimport is from './is';\nimport not from './not';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  forceCast,\n  dynamic,\n  is,\n  not,\n  deep,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.readonly.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/readonly/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport not from './not';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  not,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.readonly.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/readonly/deep/index.ts",
      "text": "import type { DeepReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T) => {\n  const out = Object.freeze(object);\n  return _unknown<DeepReadonly<T>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.readonly.deep.not": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepNotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/readonly/deep/not.ts",
      "text": "import type { DeepNotReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T) => {\n  return _unknown<DeepNotReadonly<T>>(object);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.readonly.dynamic": {
      "imports": [],
      "relativePath": "features/objects/castings/readonly/dynamic.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <U extends object>(object: U) => {\n  return Object.freeze(object);\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.readonly.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/readonly/forceCast.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: unknown) => {\n  const out = Object.freeze(object);\n  return _unknown<Readonly<T>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.readonly.index": {
      "imports": [],
      "relativePath": "features/objects/castings/readonly/index.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T) => {\n  return Object.freeze(object);\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.readonly.is": {
      "imports": [],
      "relativePath": "features/objects/castings/readonly/is.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T>(object: T): object is Readonly<T> => {\n  return Object.isFrozen(object);\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.readonly.not": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/readonly/not.ts",
      "text": "import type { NotReadonly } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object>(object: T) => {\n  return _unknown<NotReadonly<T>>(object);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.require.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const",
          "kind": "default",
          "default": "_const",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is/all",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./strict",
          "kind": "default",
          "default": "strict",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/require/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _const from './const';\nimport _index from './index';\nimport is from './is/all';\nimport strict from './strict';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  strict,\n  const: _const,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.require.const": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["AllowedNamesLow"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/require/const.ts",
      "text": "import type { AllowedNamesLow } from '../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <\n  const T extends object,\n  K extends AllowedNamesLow<T, undefined>,\n>(\n  object: T,\n  requires: Pick<T, K>,\n) => {\n  return Object.assign(object, requires);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.require.index": {
      "imports": [],
      "relativePath": "features/objects/castings/require/index.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T, requires: object) => {\n  return Object.assign(object, requires);\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.require.is.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/require/is/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport deep from './deep';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  deep,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.require.is.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../utils/require",
          "kind": "named",
          "namedImports": ["isRequiredDeep"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/require/is/deep.ts",
      "text": "import { isRequiredDeep } from '../../../utils/require';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = isRequiredDeep;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.require.is.index": {
      "imports": [],
      "relativePath": "features/objects/castings/require/is/index.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T): object is Required<T> => {\n  const values = Object.values(object);\n  return values.every(value => value !== undefined && value !== null);\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.require.strict": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["AllowedNamesLow"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/require/strict.ts",
      "text": "import type { AllowedNamesLow } from '../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends AllowedNamesLow<T, undefined>>(\n  object: T,\n  requires: Pick<T, K>,\n) => {\n  return Object.assign(object, requires);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.reverse": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/castings/reverse.ts",
      "text": "import type { Keys } from '../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends Record<Keys, Keys>>(\n  object: T,\n): { [K in keyof T as T[K]]: K } => {\n  const result: any = {};\n  for (const key in object) {\n    result[object[key]] = key;\n  }\n  return result;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.ru": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Ru"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/ru.ts",
      "text": "import type { Ru } from '../../../globals/types';\nimport { castFn } from '../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<Ru>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.trueObject": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["To"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/castings/trueObject.ts",
      "text": "import type { To } from '../../../globals/types';\nimport { castFn } from '../../../globals/utils/castFn';\nimport { isPlainObject } from '../../../globals/utils/is/object';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<To>()({ is: isPlainObject });\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.castings.type": {
      "imports": [],
      "relativePath": "features/objects/castings/type.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = Object;\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.castings.values": {
      "imports": [],
      "relativePath": "features/objects/castings/values.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(object: T): T[keyof T][] => {\n  return Object.values(object) as any;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.objects.index": {
      "imports": [],
      "relativePath": "features/objects/index.ts",
      "text": "export * from './castings/all';\nexport * from './types';\nexport * from './typings/all';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castings/all';",
          "moduleSpecifier": "./castings/all"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typings/all';",
          "moduleSpecifier": "./typings/all"
        }
      ]
    },
    "features.objects.types": {
      "imports": [
        {
          "moduleSpecifier": "../../globals/types",
          "kind": "named",
          "namedImports": ["Fn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../common/types",
          "kind": "named",
          "namedImports": ["Keys", "NotUndefined", "Primitive"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../strings/types",
          "kind": "named",
          "namedImports": ["AddString"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/types.ts",
      "text": "import type { Fn } from '../../globals/types';\nimport type { Keys, NotUndefined, Primitive } from '../common/types';\nimport { AddString } from '../strings/types';\n\n/**\n * A type that represents a true object, which is an object that does not have\n * any iterable properties or the `SymbolConstructor` property.\n *\n * @remarks This type is useful to ensure that the object is a plain object\n * without any special properties.\n *\n * @see {@linkcode Ru} for a utility type that represents a true object.\n * @see {@linkcode SymbolConstructor} for the symbol constructor type.\n */\n/**\n * TrueObject type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TrueObject = Ru & {\n  [Symbol.iterator]?: never;\n  //@ts-expect-error - 'SymbolConstructor' does not exist on type 'object'\n  [SymbolConstructor]?: never;\n};\n\n/**\n * Alias of {@linkcode TrueObject}\n */\n/**\n * To type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type To = TrueObject;\n\n/**\n * NOmit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NOmit<T, K extends keyof T> = Omit<T, K>;\n\n/**\n * DeepOmit type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepOmit<T, K extends Keys> = {\n  [P in Exclude<keyof T, K>]: T[P] extends Fn\n    ? T[P]\n    : T[P] extends object\n      ? DeepOmit<T[P], K>\n      : T[P];\n};\n\n/**\n * ReverseMap type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ReverseMap<T extends Record<Keys, Keys>> = {\n  [K in keyof T as T[K]]: K;\n};\n\n/**\n * DeepReadonly type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepReadonly<T> = T extends Primitive\n  ? T\n  : {\n      readonly [P in keyof T]: T[P] extends Fn\n        ? T[P]\n        : T[P] extends object\n          ? DeepReadonly<T[P]>\n          : T[P];\n    };\n\n/**\n * DeepPartial type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepPartial<T> = T extends Primitive\n  ? T\n  : {\n      [P in keyof T]?: T[P] extends Fn\n        ? T[P]\n        : T[P] extends object\n          ? DeepPartial<T[P]>\n          : T[P];\n    };\n\n/**\n * DeepRequired type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepRequired<T extends object | undefined> = NotUndefined<{\n  [P in keyof T]-?: T[P] extends Fn\n    ? T[P]\n    : T[P] extends object\n      ? DeepRequired<T[P]>\n      : T[P];\n}>;\n\n/**\n * NotReadonly type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NotReadonly<T extends object> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * DeepNotReadonly type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepNotReadonly<T extends object> = {\n  -readonly [P in keyof T]: T[P] extends Fn\n    ? T[P]\n    : T[P] extends object\n      ? DeepNotReadonly<T[P]>\n      : T[P];\n};\n\n// type TT = {\n//   readonly a: string;\n//   readonly b: {\n//     readonly c: number;\n//     readonly d: {\n//       readonly e: boolean;\n//       readonly f: {\n//         readonly g: string[];\n//       };\n//     };\n//   };\n//   readonly h: () => void;\n//   readonly i: {\n//     readonly j: {\n//       readonly k: string;\n//       readonly l: {\n//         readonly m: number;\n//       };\n//     };\n//   };\n// };\n\n/**\n * ValuesOf type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ValuesOf<T, U = any> = Extract<T[keyof T], U>;\n/**\n * ObjectValuesOf type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ObjectValuesOf<T> = Exclude<\n  Extract<ValuesOf<T>, object>,\n  Array<any>\n>;\n\n/**\n * ExpressO type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExpressO<T extends object> = {\n  [K in keyof T]: T[K];\n};\n\n/**\n * DeepExpressO type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepExpressO<T extends object> =\n  ExpressO<T> extends infer P1\n    ? {\n        [K in keyof P1]: P1[K] extends object\n          ? DeepExpressO<P1[K]>\n          : P1[K];\n      }\n    : never;\n\ntype _RequiredLow<T extends object> =\n  Required<SubTypeLow<T, undefined>> extends infer P\n    ? {\n        [K in keyof P]: P[K] | undefined;\n      } & NotSubTypeLow<T, undefined>\n    : never;\n\n/**\n * RequiredLow type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type RequiredLow<T extends object> = ExpressO<_RequiredLow<T>>;\n\n/**\n * DeepRequiredLow type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepRequiredLow<T extends object> =\n  RequiredLow<T> extends infer P1\n    ? {\n        [K1 in keyof P1]: Exclude<\n          P1[K1],\n          undefined\n        > extends infer P2 extends object\n          ? DeepRequiredLow<P2>\n          : P1[K1];\n      }\n    : never;\n\n/**\n * Require type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Require<T, K extends keyof T> = NOmit<T, K> &\n  Required<Pick<T, K>>;\n\n/**\n * RequiredBy type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type RequiredBy<T, U> = Required<PickBy<T, U>> & PickNotBy<T, U>;\n\n/**\n * Prop type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Prop<T, K> = K extends keyof T ? T[K] : never;\n\n/**\n * PickNoInfer type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PickNoInfer<T, S> = Pick<T, Extract<keyof T, S>>;\n\n/**\n * PickBy type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PickBy<T, U> = {\n  [P in keyof T as T[P] extends U ? P : never]: Extract<T[P], U>;\n};\n\n/**\n * PickKeysBy type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PickKeysBy<T, U> = keyof PickBy<T, U>;\n\n/**\n * PickNotBy type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PickNotBy<T, U> = {\n  [P in keyof T as T[P] extends U ? never : P]: Exclude<T[P], U>;\n};\n\n/**\n * PickKeysNotBy type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PickKeysNotBy<T, U> = keyof PickNotBy<T, U>;\n\n/**\n * OnPropChangedMethods type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type OnPropChangedMethods<T, I extends keyof T = keyof T> = T & {\n  [K in Extract<PickKeysBy<T, (...args: any) => any>, I> &\n    string as AddString<Capitalize<K>, 'on', 'Changed'>]: (\n    cb: (newValue: T[K]) => void,\n  ) => void;\n};\n\n/**\n * PartialUndefiny type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PartialUndefiny<T> = PickNotBy<T, undefined> &\n  Partial<PickBy<T, undefined>>;\n\n/**\n * Nullify type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Nullify<T> = PickNotBy<T, null> & Partial<PickBy<T, null>>;\n\ntype _OmitWithoutPartial<T, O extends string> = {\n  [key in keyof Omit<T, O>]: O extends keyof T[key]\n    ? _OmitWithoutPartial<T[key], O>\n    : T[key];\n};\n\ntype _OmitWithPartial<T, O extends string> = PartialUndefiny<\n  Nullify<_OmitWithoutPartial<T, O>>\n>;\n\n/**\n * OmitRecursive type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type OmitRecursive<T, O extends string> = {\n  [key in keyof _OmitWithPartial<T, O>]: _OmitWithPartial<T[key], O>;\n};\n\n/**\n * Unionize type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Unionize<T extends Record<string, any>> = {\n  [P in keyof T]: { [Q in P]: T[P] };\n}[keyof T];\n\ntype WithChildren<\n  T,\n  _omit extends string,\n  _withChildren extends boolean = false,\n> = _withChildren extends true ? T : Omit<T, _omit>;\n\ntype DefaultK<S extends string, D extends string> = S extends '' ? D : S;\n\n// #region type _FlatMapByKey\n/**\n * _FlatMapByKey type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type _FlatMapByKey<\n  T extends object,\n  _omit extends PickKeysBy<T, object>,\n  _withChildren extends boolean = false,\n  Delimiter extends string = '.',\n  Keys extends string = '',\n  K extends string = keyof T[_omit] & string,\n> = T extends {\n  [Key in _omit]?: any;\n}\n  ? K extends keyof T[_omit]\n    ? T[_omit][K] extends infer TK extends object\n      ?\n          | _FlatMapByKey<\n              TK,\n              _omit,\n              _withChildren,\n              Delimiter,\n              `${Keys}${Delimiter}${K}`\n            >\n          | {\n              [key in DefaultK<Keys, Delimiter>]: WithChildren<\n                T,\n                _omit,\n                _withChildren\n              >;\n            }\n      : {\n          [key in DefaultK<Keys, Delimiter>]: WithChildren<\n            T,\n            _omit,\n            _withChildren\n          >;\n        }\n    : never\n  : {\n      [key in DefaultK<Keys, Delimiter>]: WithChildren<\n        T,\n        _omit,\n        _withChildren\n      >;\n    };\n\n// #region SubTypes\ntype FilterFlags<Base, Condition> = {\n  [Key in keyof Base]: Base[Key] extends Condition ? Key : never;\n};\n\ntype NotFilterFlags<Base, Condition> = {\n  [Key in keyof Base]: Base[Key] extends Condition ? never : Key;\n};\n\ntype FilterFlagsLow<Base, Condition> = {\n  [Key in keyof Base]: Condition extends Base[Key] ? Key : never;\n};\n\ntype NotFilterFlagsLow<Base, Condition> = {\n  [Key in keyof Base]: Condition extends Base[Key] ? never : Key;\n};\n\n/**\n * AllowedNames type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AllowedNames<Base, Condition> = FilterFlags<\n  Base,\n  Condition\n>[keyof Base];\n\n/**\n * NotAllowedNames type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NotAllowedNames<Base, Condition> = NotFilterFlags<\n  Base,\n  Condition\n>[keyof Base];\n\n/**\n * AllowedNamesLow type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AllowedNamesLow<Base, Condition> = FilterFlagsLow<\n  Base,\n  Condition\n>[keyof Base];\n\n/**\n * NotAllowedNamesLow type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NotAllowedNamesLow<Base, Condition> = NotFilterFlagsLow<\n  Base,\n  Condition\n>[keyof Base];\n\n/**\n * SubType type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type SubType<Base extends object, Condition> = Pick<\n  Base,\n  AllowedNames<Base, Condition>\n>;\n\n/**\n * DeepSubType type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepSubType<Base extends object, Condition> = {\n  [K in keyof Base as K extends AllowedNames<Base, Condition>\n    ? K\n    : never]: Base[K] extends object\n    ? DeepSubType<Base[K], Condition>\n    : Base[K];\n};\n\n/**\n * NotSubType type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NotSubType<Base extends object, Condition> = Pick<\n  Base,\n  NotAllowedNames<Base, Condition>\n>;\n\n/**\n * DeepNotSubType type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepNotSubType<Base extends object, Condition> = {\n  [K in keyof Base as K extends NotAllowedNames<Base, Condition>\n    ? K\n    : never]: Base[K] extends object\n    ? DeepNotSubType<Base[K], Condition>\n    : Base[K];\n};\n\n/**\n * SubTypeLow type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type SubTypeLow<Base extends object, Condition> = Pick<\n  Base,\n  AllowedNamesLow<Base, Condition>\n>;\n\n/**\n * NotSubTypeLow type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NotSubTypeLow<Base extends object, Condition> = Pick<\n  Base,\n  NotAllowedNamesLow<Base, Condition>\n>;\n\n// #endregion\n\ninterface _Never {\n  [key: Keys]: DeepNever;\n}\n\n/**\n * DeepNever type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type DeepNever = never | _Never;\n\n/**\n * Dn type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Dn = DeepNever;\n\n/**\n * Neverify type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Neverify<T> = T extends DeepNever ? never : T;\n\n/**\n * Ru type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Ru = Record<Keys, unknown>;\n\n/**\n * Rn type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Rn = Record<Keys, never>;\n\n/**\n * Ra type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Ra = Record<Keys, any>;\n\n// #region NoExtraKeys\n\n/**\n * Extracts keys from type T that represent object properties which should be\n * recursively processed for no-extra-keys validation.\n *\n * @template T - The type to extract recursive keys from.\n * @template Schema - The schema type to compare against.\n */\ntype RecursiveObjectKeys<T, Schema> = {\n  [K in keyof T & keyof Schema]: T[K] extends TrueObject ? K : never;\n}[keyof T & keyof Schema];\n\n/**\n * Generic type that restricts extra keys deeply on any object type.\n * Works with partial objects and ensures all keys match the schema exactly.\n *\n * @template T - The type to validate (the actual value type).\n * @template Schema - The schema type that defines allowed keys.\n *\n * @remarks\n * This type performs deep validation ensuring:\n * 1. No extra keys are present at the top level\n * 2. All nested object properties are recursively validated\n * 3. Works with partial/optional properties\n * 4. Preserves readonly modifiers\n *\n * @example\n * ```typescript\n * type MySchema = {\n *   name: string;\n *   config?: {\n *     value: number;\n *     nested?: {\n *       deep: boolean;\n *     };\n *   };\n * };\n *\n * // Valid - all keys match schema\n * type Valid = NoExtraKeys<{ name: 'test'; config: { value: 1 } }, MySchema>;\n *\n * // Invalid - 'extra' key is not in schema, will be typed as 'never'\n * type Invalid = NoExtraKeys<{ name: 'test'; extra: true }, MySchema>;\n * ```\n *\n * @see {@linkcode NoExtraKeysStrict} for a stricter version that requires exact match.\n */\n/**\n * NoExtraKeys type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NoExtraKeys<T, Schema> = T & {\n  [K in Exclude<keyof T, keyof Schema>]: never;\n} & {\n  [K in RecursiveObjectKeys<T, Schema>]: NoExtraKeys<\n    NotUndefined<T[K]>,\n    NotUndefined<Schema[K]>\n  >;\n};\n\n/**\n * A stricter version of {@linkcode NoExtraKeys} that also validates\n * that all keys in the schema are present in the type T.\n *\n * @template T - The type to validate (the actual value type).\n * @template Schema - The schema type that defines allowed keys.\n *\n * @remarks\n * Use this when you want to ensure not only that there are no extra keys,\n * but also that all required keys from the schema are present.\n *\n * @example\n * ```typescript\n * type MySchema = {\n *   name: string;\n *   value: number;\n * };\n *\n * // T must have both 'name' and 'value'\n * type Strict = NoExtraKeysStrict<{ name: 'test'; value: 1 }, MySchema>;\n * ```\n */\n/**\n * NoExtraKeysStrict type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type NoExtraKeysStrict<T extends Schema, Schema> = NoExtraKeys<\n  T,\n  Schema\n>;\n\n/**\n * StateValue type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type StateValue = string | StateValueMap;\n\n/**\n * StateValueMap interface - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport interface StateValueMap {\n  [key: string]: StateValue;\n}\n\n// #endregion NoExtraKeys\n\n    ",
      "exports": []
    },
    "features.objects.typings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./byKey",
          "kind": "default",
          "default": "byKey",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./entries",
          "kind": "default",
          "default": "entries",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./freeze/all",
          "kind": "default",
          "default": "freeze",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./hasKeys/all",
          "kind": "default",
          "default": "hasKeys",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./keyTypes/all",
          "kind": "default",
          "default": "keyTypes",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./keysOf",
          "kind": "default",
          "default": "keys",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./omit/all",
          "kind": "default",
          "default": "omit",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./pick/all",
          "kind": "default",
          "default": "pick",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./primitive",
          "kind": "default",
          "default": "primitive",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ra",
          "kind": "default",
          "default": "ra",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./readonly/all",
          "kind": "default",
          "default": "readonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./require/all",
          "kind": "default",
          "default": "require",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./reverse",
          "kind": "default",
          "default": "reverse",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./rn",
          "kind": "default",
          "default": "rn",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./ru",
          "kind": "default",
          "default": "ru",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./trueObject",
          "kind": "default",
          "default": "trueObject",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./values",
          "kind": "default",
          "default": "values",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./noExtra",
          "kind": "default",
          "default": "noExtra",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/all.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\nimport byKey from './byKey';\nimport entries from './entries';\nimport freeze from './freeze/all';\nimport hasKeys from './hasKeys/all';\nimport keyTypes from './keyTypes/all';\nimport keys from './keysOf';\nimport omit from './omit/all';\nimport pick from './pick/all';\nimport primitive from './primitive';\nimport ra from './ra';\nimport readonly from './readonly/all';\nimport require from './require/all';\nimport reverse from './reverse';\nimport rn from './rn';\nimport ru from './ru';\nimport trueObject from './trueObject';\nimport values from './values';\nimport noExtra from './noExtra';\n\n/**\n * typings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typings = typeFn<object>()({\n  trueObject,\n  keys,\n  values,\n  entries,\n  byKey,\n  keyTypes,\n  hasKeys,\n  omit,\n  pick,\n  reverse,\n  readonly,\n  freeze,\n  require,\n  ru,\n  rn,\n  ra,\n  primitive,\n  noExtra,\n});\n\n    ",
      "exports": []
    },
    "features.objects.typings.byKey": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/byKey.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends keyof T>(_?: T, __?: K) =>\n  _unknown<T[K]>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.entries": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/entries.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<[keyof T, T[keyof T]][]>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./dynamic",
          "kind": "default",
          "default": "dynamic",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "freeze",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep/all';\nimport dynamic from './dynamic';\nimport forceCast from './forceCast';\nimport freeze from './index';\nimport is from './is';\nimport not from './not';\n\n/**\n * freezeTyping const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst freezeTyping = expandFn(freeze, {\n  dynamic,\n  forceCast,\n  is,\n  not,\n  deep,\n});\n\nexport default freezeTyping;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "deepFreeze",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport deepFreeze from './index';\nimport not from './not';\n\n/**\n * deep const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst deep = expandFn(deepFreeze, {\n  not,\n});\n\nexport default deep;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/deep/index.ts",
      "text": "import type { DeepReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<DeepReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.deep.not": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepNotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/deep/not.ts",
      "text": "import type { DeepNotReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<DeepNotReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.dynamic": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/dynamic.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends Readonly<T>>(_?: T) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/forceCast.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: unknown) => _unknown<Readonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<Readonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/is.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends Readonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.freeze.not": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/freeze/not.ts",
      "text": "import type { NotReadonly } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<NotReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.hasKeys._all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Equals", "Keys"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/hasKeys/_all.ts",
      "text": "import type { Equals, Keys } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends Keys[]>(_?: T, ...__: K) =>\n  _unknown<Equals<K[number], keyof T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.hasKeys.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./_all",
          "kind": "default",
          "default": "all",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./typings",
          "kind": "default",
          "default": "typings",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/hasKeys/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport all from './_all';\nimport _index from './index';\nimport typings from './typings';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  typings,\n  all,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.hasKeys.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/hasKeys/index.ts",
      "text": "import type { Keys } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends Keys[]>(_?: T, ...__: K) =>\n  _unknown<K[number] extends keyof T ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.hasKeys.typings": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes", "KeyTypesFrom"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/hasKeys/typings.ts",
      "text": "import type { KeyTypes, KeyTypesFrom } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <K extends KeyTypes>(_?: K) => {\n  const _out = <T extends object>(_?: T) =>\n    _unknown<T extends KeyTypesFrom<K> ? true : false>();\n\n  return _out;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.keyTypes.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./from",
          "kind": "default",
          "default": "from",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/keyTypes/all.ts",
      "text": "import type { KeyTypes } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\nimport from from './from';\nimport _index from './index';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<KeyTypes>()({\n  is: _index,\n  from,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.keyTypes.from": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes", "KeyTypesFrom"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/keyTypes/from.ts",
      "text": "import type { KeyTypes, KeyTypesFrom } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends KeyTypes>(_?: T) => _unknown<KeyTypesFrom<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.keyTypes.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/keyTypes/index.ts",
      "text": "import type { KeyTypes } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<KeyTypes>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.keysOf": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/keysOf.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\nimport { expandFn } from '../../../globals/utils/expandFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(<T extends object>(_?: T) => _unknown<(keyof T)[]>(), {\n  union: <T extends object>(_?: T) => _unknown<keyof T>(),\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.noExtra": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["NoExtraKeysStrict"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/noExtra.ts",
      "text": "import type { NoExtraKeysStrict } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\ntype P<T> = NoExtraKeysStrict<T, T>;\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <Schema>(_?: Schema) => {\n  return <T extends P<Schema>>(_?: T) => _unknown<T>();\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./by/all",
          "kind": "default",
          "default": "by",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const/all",
          "kind": "default",
          "default": "_const",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport by from './by/all';\nimport _const from './const/all';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  const: _const,\n  is,\n  by,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.by.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const/all",
          "kind": "default",
          "default": "_const",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/by/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _const from './const/all';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n  const: _const,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.by.const.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/by/const/all.ts",
      "text": "import { expandFn } from '../../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.by.const.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotSubType", "ValuesOf"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/by/const/index.ts",
      "text": "import type { NotSubType, ValuesOf } from '../../../../../../globals/types';\nimport { _unknown } from '../../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object, K extends ValuesOf<T>[]>(\n  _?: T,\n  ...__: K\n) => _unknown<NotSubType<T, K[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.by.const.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotSubType", "ValuesOf"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/by/const/is.ts",
      "text": "import type { NotSubType, ValuesOf } from '../../../../../../globals/types';\nimport { _unknown } from '../../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object, K extends ValuesOf<T>[]>(\n  _?: T,\n  ...__: K\n) => {\n  const _out = <U>(_?: U) =>\n    _unknown<U extends NotSubType<T, K[number]> ? true : false>();\n\n  return _out;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.by.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotSubType"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/by/index.ts",
      "text": "import type { NotSubType } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends any[]>(_?: T, ...__: K) =>\n  _unknown<NotSubType<T, K[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.by.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotSubType"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/by/is.ts",
      "text": "import type { NotSubType } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends any[]>(_?: T, ...__: K) => {\n  const _out = <U>(_?: U) =>\n    _unknown<U extends NotSubType<T, K[number]> ? true : false>();\n  return _out;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.const.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/const/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.const.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/const/index.ts",
      "text": "import { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object, K extends (keyof T)[]>(\n  _?: T,\n  ...__: K\n) => _unknown<Omit<T, K[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.const.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/const/is.ts",
      "text": "import { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T, K extends (keyof T)[]>(_?: T, ...__: K) => {\n  const _out = <U>(_?: U) =>\n    _unknown<U extends Omit<T, K[number]> ? true : false>();\n\n  return _out;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/index.ts",
      "text": "import type { Keys } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T, K extends Keys[]>(_?: T, ...__: K) =>\n  _unknown<Omit<T, K[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.omit.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/omit/is.ts",
      "text": "import type { Keys } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T, K extends Keys[]>(_?: T, ...__: K) => {\n  const _out = <U>(_?: U) =>\n    _unknown<U extends Omit<T, K[number]> ? true : false>();\n\n  return _out;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.pick.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./by",
          "kind": "default",
          "default": "by",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "pick",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/pick/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport by from './by';\nimport deep from './deep/all';\nimport pick from './index';\n\n/**\n * pickTyping const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst pickTyping = expandFn(pick, {\n  by,\n  deep,\n});\n\nexport default pickTyping;\n\n    ",
      "exports": []
    },
    "features.objects.typings.pick.by": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["SubType"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/pick/by.ts",
      "text": "import type { SubType } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends any[]>(_?: T, ...__: K) =>\n  _unknown<SubType<T, K[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.pick.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./by",
          "kind": "default",
          "default": "by",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "deepPick",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/pick/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport by from './by';\nimport deepPick from './index';\n\n/**\n * deep const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst deep = expandFn(deepPick, {\n  by,\n});\n\nexport default deep;\n\n    ",
      "exports": []
    },
    "features.objects.typings.pick.deep.by": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["SubType"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/pick/deep/by.ts",
      "text": "import type { SubType } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends any[]>(_?: T, ...__: K) =>\n  _unknown<SubType<T, K[number]>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.pick.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/pick/deep/index.ts",
      "text": "import { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends keyof T>(_?: T, ...__: K[]) =>\n  _unknown<Pick<T, K>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.pick.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/pick/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, K extends keyof T>(_?: T, ...__: K[]) =>\n  _unknown<Pick<T, K>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.primitive": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/primitive.ts",
      "text": "import type { PrimitiveObjectMap } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<PrimitiveObjectMap>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.ra": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Ra"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/ra.ts",
      "text": "import type { Ra } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Ra>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep/all",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./dynamic",
          "kind": "default",
          "default": "dynamic",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./forceCast",
          "kind": "default",
          "default": "forceCast",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "readonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not/all",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type_",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport deep from './deep/all';\nimport dynamic from './dynamic';\nimport forceCast from './forceCast';\nimport readonly from './index';\nimport is from './is';\nimport not from './not/all';\nimport type_ from './type';\n\n/**\n * _readonly const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst _readonly = expandFn(readonly, {\n  forceCast,\n  dynamic,\n  type: type_,\n  is,\n  not,\n  deep,\n});\n\nexport default _readonly;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.deep.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "deepReadonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./not/all",
          "kind": "default",
          "default": "not",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/deep/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport deepReadonly from './index';\nimport is from './is';\nimport not from './not/all';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(deepReadonly, {\n  not,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.deep.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/deep/index.ts",
      "text": "import type { DeepReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<DeepReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.deep.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/deep/is.ts",
      "text": "import type { DeepReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends DeepReadonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.deep.not.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "deepNotReadonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/deep/not/all.ts",
      "text": "import { expandFn } from '../../../../../../globals/utils/expandFn';\nimport deepNotReadonly from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(deepNotReadonly, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.deep.not.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepNotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/deep/not/index.ts",
      "text": "import type { DeepNotReadonly } from '../../../../../../globals/types';\nimport { _unknown } from '../../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object>(_?: T) =>\n  _unknown<DeepNotReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.deep.not.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepNotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/deep/not/is.ts",
      "text": "import type { DeepNotReadonly } from '../../../../../../globals/types';\nimport { _unknown } from '../../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object>(_?: T) =>\n  _unknown<T extends DeepNotReadonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.dynamic": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/dynamic.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends Readonly<T>>(_?: T) => _unknown<T>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.forceCast": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/forceCast.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: unknown) => _unknown<Readonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) => _unknown<Readonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/is.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends Readonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.not.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "notReadonly",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/not/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport notReadonly from './index';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(notReadonly, {\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.not.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/not/index.ts",
      "text": "import type { NotReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object>(_?: T) => _unknown<NotReadonly<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.not.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["NotReadonly"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/not/is.ts",
      "text": "import type { NotReadonly } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object>(_?: T) =>\n  _unknown<T extends NotReadonly<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.readonly.type": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/readonly/type.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = () => _unknown<Readonly<object>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.require.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./const",
          "kind": "default",
          "default": "const_",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "require",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is/all",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./strict",
          "kind": "default",
          "default": "strict",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/require/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport const_ from './const';\nimport require from './index';\nimport is from './is/all';\nimport strict from './strict';\n\n/**\n * requireTyping const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst requireTyping = expandFn(require, {\n  const: const_,\n  strict,\n  is,\n});\n\nexport default requireTyping;\n\n    ",
      "exports": []
    },
    "features.objects.typings.require.const": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/require/const.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends object, const R extends object>(\n  _?: T,\n  __?: R,\n) => _unknown<T & R>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.require.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/require/index.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, R extends object>(_?: T, __?: R) =>\n  _unknown<T & R>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.require.is.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./deep",
          "kind": "default",
          "default": "deep",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "requireIs",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/require/is/all.ts",
      "text": "import { expandFn } from '../../../../../globals/utils/expandFn';\nimport deep from './deep';\nimport requireIs from './index';\n\n/**\n * is const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst is = expandFn(requireIs, {\n  deep,\n});\n\nexport default is;\n\n    ",
      "exports": []
    },
    "features.objects.typings.require.is.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepRequired"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/require/is/deep.ts",
      "text": "import type { DeepRequired } from '../../../../../globals/types';\nimport { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object>(_?: T) =>\n  _unknown<T extends DeepRequired<T> ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.require.is.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/require/is/index.ts",
      "text": "import { _unknown } from '../../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, R extends object>(_?: T, __?: R) =>\n  _unknown<T extends T & R ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.require.strict": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/require/strict.ts",
      "text": "import { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends object, R extends Partial<T>>(_?: T, __?: R) =>\n  _unknown<T & Required<R>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.reverse": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/reverse.ts",
      "text": "import type { Keys } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends Record<Keys, Keys>>(_?: T) => {\n  return _unknown<{\n    [K in keyof T as T[K]]: K;\n  }>();\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.rn": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Rn"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/rn.ts",
      "text": "import type { Rn } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Rn>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.ru": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Ru"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/ru.ts",
      "text": "import type { Ru } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Ru>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.trueObject": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["To"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/trueObject.ts",
      "text": "import type { To } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<To>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.typings.values": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/typings/values.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\nimport { expandFn } from '../../../globals/utils/expandFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(\n  <T extends object>(_?: T) => _unknown<T[keyof T][]>(),\n  {\n    union: <T extends object>(_?: T) => _unknown<T[keyof T]>(),\n  },\n);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.objects.utils.entries": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["KeyTypes"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/utils/entries.ts",
      "text": "import type { KeyTypes } from '../../../globals/types';\n\n/**\n * checkEntries variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const checkEntries = (keys: KeyTypes, object: object) => {\n  const entries = Object.entries(keys);\n  return entries.every(([key, type]) => {\n    const check1 = key in object;\n    if (!check1) return false;\n\n    const value = (object as any)[key];\n    if (typeof type === 'string') {\n      return typeof value === type;\n    } else if (typeof type === 'function') {\n      return type(value);\n    }\n    return false;\n  });\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.omit.deep.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Primitive2"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["Picker"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/utils/omit.deep.is.ts",
      "text": "import type { Primitive2 } from '../../../globals/types';\nimport { isPlainObject } from '../../../globals/utils/is/object';\nimport type { Picker } from './types';\n\n/**\n * omitDeepIs variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const omitDeepIs = (\n  by: Picker,\n  object: object,\n  ...valuesOrKeys: Primitive2[]\n) => {\n  const entries = Object.entries(object);\n  for (const [key, value] of entries) {\n    const isObject = isPlainObject(value);\n    if (isObject) {\n      const isDeep = omitDeepIs(by, value, ...valuesOrKeys);\n      if (!isDeep) return false;\n    } else {\n      const shouldOmit =\n        by === 'element'\n          ? valuesOrKeys.includes(value)\n          : valuesOrKeys.includes(key);\n      if (shouldOmit) return false;\n    }\n  }\n  return true;\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.omit.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["Picker"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/utils/omit.deep.ts",
      "text": "import type { PrimitiveObjectMap } from '../../../globals/types';\nimport { isPlainObject } from '../../../globals/utils/is/object';\nimport type { Picker } from './types';\n\nconst __omitDeep = (\n  by: Picker,\n  object: PrimitiveObjectMap,\n  ...valuesOrKeys: any[]\n) => {\n  const entries = Object.entries(object);\n  const result: PrimitiveObjectMap = {};\n\n  entries.forEach(([key, value]) => {\n    const isObject = isPlainObject(value);\n    if (isObject) {\n      const picked = __omitDeep(\n        by,\n        value as PrimitiveObjectMap,\n        ...valuesOrKeys,\n      );\n\n      result[key] = picked;\n    } else if (by === 'key' && !valuesOrKeys.includes(key)) {\n      result[key] = value;\n    } else if (\n      by === 'element' &&\n      !!value &&\n      !valuesOrKeys.includes(value)\n    ) {\n      result[key] = value;\n    }\n  });\n\n  return result;\n};\n\n/**\n * omitDeep variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const omitDeep = (\n  by: Picker,\n  object: PrimitiveObjectMap,\n  ...valuesOrKeys: any[]\n) => {\n  const result = __omitDeep(by, object, ...valuesOrKeys);\n\n  return result;\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.omit.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["Picker"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/utils/omit.is.ts",
      "text": "import type { PrimitiveObjectMap } from '../../../globals/types';\nimport type { Picker } from './types';\n\n/**\n * omitIs variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const omitIs = (\n  by: Picker,\n  object: PrimitiveObjectMap,\n  ...valuesOrKeys: any[]\n) => {\n  const entries = Object.entries(object);\n  for (const [key, value] of entries) {\n    const checkKey = by === 'key' && valuesOrKeys.includes(key);\n    const checkElement = by === 'element' && valuesOrKeys.includes(value);\n    if (checkKey) {\n      return false;\n    } else if (checkElement) {\n      return false;\n    }\n  }\n  return true;\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.omit": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["Picker"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/utils/omit.ts",
      "text": "import type { PrimitiveObjectMap } from '../../../globals/types';\nimport type { Picker } from './types';\n\n/**\n * omit variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const omit = (\n  by: Picker,\n  object: PrimitiveObjectMap,\n  ...valuesOrKeys: any[]\n) => {\n  const result: any = {};\n\n  const entries = Object.entries(object);\n  entries.forEach(([key, value]) => {\n    const checkKey = by === 'key' && !valuesOrKeys.includes(key);\n    const checkElement = by === 'element' && !valuesOrKeys.includes(value);\n    if (checkKey) {\n      result[key] = value;\n    } else if (checkElement) {\n      result[key] = value;\n    }\n  });\n\n  return result;\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.pick.deep": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/is/object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["Picker"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/utils/pick.deep.ts",
      "text": "import { isPlainObject } from '../../../globals/utils/is/object';\nimport type { Picker } from './types';\n\n/**\n * pickDeep variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const pickDeep = (\n  by: Picker,\n  object: object,\n  ...valuesOrKeys: any[]\n) => {\n  const result: any = {};\n\n  for (const key in object) {\n    if (Object.prototype.hasOwnProperty.call(object, key)) {\n      const element = (object as any)[key];\n      const isObject = isPlainObject(element);\n\n      if (isObject) {\n        const picked = pickDeep(by, element, ...valuesOrKeys);\n        if (Object.keys(picked).length > 0) {\n          result[key] = picked;\n        }\n      } else {\n        const shouldPick =\n          by === 'element'\n            ? valuesOrKeys.includes(element)\n            : valuesOrKeys.includes(key);\n        if (shouldPick) result[key] = element;\n      }\n    }\n  }\n\n  return result;\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.pick": {
      "imports": [
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["Picker"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/objects/utils/pick.ts",
      "text": "import type { Picker } from './types';\n\n/**\n * pick variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const pick = (by: Picker, object: object, ...keys: any[]) => {\n  const result: any = {};\n  const entries = Object.entries(object);\n\n  entries.forEach(([key, value]) => {\n    const shouldPick =\n      by === 'element' ? keys.includes(value) : keys.includes(key);\n\n    if (shouldPick) {\n      result[key] = value;\n    }\n  });\n\n  return result;\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.require": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["DeepRequired"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/merge",
          "kind": "named",
          "namedImports": ["mergeIs"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../globals/utils/is/object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/objects/utils/require.ts",
      "text": "import type { DeepRequired } from '../../../globals/types';\nimport { mergeIs } from '../../../globals/utils/is/merge';\nimport { isPlainObject } from '../../../globals/utils/is/object';\n\n/**\n * isRequiredDeep variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isRequiredDeep = (\n  object: unknown,\n): object is DeepRequired<any> => {\n  const isObject = isPlainObject(object);\n  if (isObject) {\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        const element = (object as any)[key];\n        const isPrimitiveMap = isRequiredDeep(element);\n        if (!isPrimitiveMap) return false;\n      }\n    }\n    return true;\n  }\n\n  const isArray = Array.isArray(object);\n  if (isArray) {\n    for (const item of object) {\n      const isPrimitiveMap = isRequiredDeep(item);\n      if (!isPrimitiveMap) return false;\n    }\n    return true;\n  }\n\n  const checker = mergeIs(undefined, null);\n\n  return !checker(object);\n};\n\n    ",
      "exports": []
    },
    "features.objects.utils.types": {
      "imports": [],
      "relativePath": "features/objects/utils/types.ts",
      "text": "/**\n * Picker type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Picker = 'element' | 'key';\n",
      "exports": []
    },
    "features.promises.index": {
      "imports": [],
      "relativePath": "features/promises/index.ts",
      "text": "export * from './types';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        }
      ]
    },
    "features.promises.types": {
      "imports": [],
      "relativePath": "features/promises/types.ts",
      "text": "/**\n * PromisifyMethod type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PromisifyMethod<T> = T extends (...args: infer P) => infer R\n  ? R extends Promise<any>\n    ? T\n    : (...args: P) => Promise<R>\n  : never;\n\n/**\n * PromisifyObject type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PromisifyObject<T extends Record<string, unknown>> = T & {\n  [P in keyof T as PromisifyMethod<T[P]> extends never\n    ? never\n    : `${string & P}Async`]: PromisifyMethod<T[P]>;\n};\n",
      "exports": []
    },
    "features.strings.castings.add": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["AddString"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/add.ts",
      "text": "import type { AddString } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends string, Before extends string, After extends string>(\n  value: T,\n  before = '' as Before,\n  after = '' as After,\n) => {\n  const out = `${before}${value}${after}`;\n  return _unknown<AddString<T, Before, After>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": ["DEFAULT_DELIMITER"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./add",
          "kind": "default",
          "default": "add",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./contains",
          "kind": "default",
          "default": "contains",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./endsWith",
          "kind": "default",
          "default": "endsWith",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./getLength",
          "kind": "default",
          "default": "getLength",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./includes",
          "kind": "default",
          "default": "includes",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./instance",
          "kind": "default",
          "default": "instance",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./join",
          "kind": "default",
          "default": "join",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./letters/all",
          "kind": "default",
          "default": "letters",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./splitBy",
          "kind": "default",
          "default": "splitBy",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./startsWith",
          "kind": "default",
          "default": "startsWith",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./toLowerCase",
          "kind": "default",
          "default": "toLowerCase",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./toUpperCase",
          "kind": "default",
          "default": "toUpperCase",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./type",
          "kind": "default",
          "default": "type",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport { DEFAULT_DELIMITER } from '../constants';\nimport add from './add';\nimport contains from './contains';\nimport endsWith from './endsWith';\nimport getLength from './getLength';\nimport includes from './includes';\nimport _index from './index';\nimport instance from './instance';\nimport is from './is';\nimport join from './join';\nimport letters from './letters/all';\nimport splitBy from './splitBy';\nimport startsWith from './startsWith';\nimport toLowerCase from './toLowerCase';\nimport toUpperCase from './toUpperCase';\nimport type from './type';\n\n/**\n * castings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castings = expandFn(_index, {\n  is,\n  instance,\n  type,\n  getLength,\n  startsWith,\n  endsWith,\n  includes,\n  contains,\n  toLowerCase,\n  toUpperCase,\n  letters,\n  add,\n  join,\n  splitBy,\n  DEFAULT_DELIMITER,\n});\n\n    ",
      "exports": []
    },
    "features.strings.castings.contains": {
      "imports": [
        {
          "moduleSpecifier": "./includes",
          "kind": "default",
          "default": "includes",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/contains.ts",
      "text": "import includes from './includes';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <U extends string[]>(\n  value: unknown,\n  ...segments: U\n): value is `${string}${U[number]}${string}` =>\n  includes(value, ...segments);\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.endsWith": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isTypeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/endsWith.ts",
      "text": "import { isTypeFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <U extends string>(\n  value: unknown,\n  suffix: U,\n): value is `${string}${U}` => {\n  return isTypeFn('string')(value) && value.endsWith(suffix);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.getLength": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/getLength.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends string>(value: T) => {\n  const out = value.length;\n  return _unknown<T['length']>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.includes": {
      "imports": [],
      "relativePath": "features/strings/castings/includes.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <U extends string[]>(\n  value: unknown,\n  ...segments: U\n): value is `${string}${U[number]}${string}` => {\n  if (typeof value !== 'string') return false;\n\n  // Check if the string contains any of the segments\n  for (const seg of segments) {\n    if (value.includes(seg)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport default fn;\n",
      "exports": []
    },
    "features.strings.castings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/index.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<string>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.instance": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/instance.ts",
      "text": "import { castFn } from '../../../globals/utils/castFn';\n\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<String>()({\n  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n  is: (value: unknown): value is String => {\n    return value instanceof String;\n  },\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.is": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isTypeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/is.ts",
      "text": "import { isTypeFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = isTypeFn('string');\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.join": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["JoinString"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/join.ts",
      "text": "import type { JoinString } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends readonly string[], S extends string = ' '>(\n  sep = ' ' as S,\n  ...args: T\n) => {\n  const out = args.join(sep);\n  return _unknown<JoinString<T, S>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.letters.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./lower",
          "kind": "default",
          "default": "lower",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./upper",
          "kind": "default",
          "default": "upper",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/letters/all.ts",
      "text": "import { expandFn } from '../../../../globals/utils/expandFn';\nimport _index from './index';\nimport is from './is';\nimport lower from './lower';\nimport upper from './upper';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(_index, {\n  lower,\n  upper,\n  is,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.letters.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Letters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/letters/index.ts",
      "text": "import type { Letters } from '../../../../globals/types';\nimport { castFn } from '../../../../globals/utils/castFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<Letters>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.letters.is": {
      "imports": [
        {
          "moduleSpecifier": "../../constants",
          "kind": "named",
          "namedImports": ["ENGLISH_LETTERS"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Letters"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/strings/castings/letters/is.ts",
      "text": "import { ENGLISH_LETTERS } from '../../constants';\nimport type { Letters } from '../../../../globals/types';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = (value: unknown): value is Letters => {\n  if (typeof value !== 'string') return false;\n  if (value.length === 0) return false;\n\n  // Check if all characters are English letters\n  for (const char of value.toLowerCase()) {\n    if (!ENGLISH_LETTERS.includes(char as any)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.letters.lower": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["LowerLetters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/letters/lower.ts",
      "text": "import type { LowerLetters } from '../../../../globals/types';\nimport { castFn } from '../../../../globals/utils/castFn';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<LowerLetters>()({\n  is: (value: unknown): value is LowerLetters => {\n    return (\n      typeof value === 'string' &&\n      is(value) &&\n      value === value.toLowerCase()\n    );\n  },\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.letters.upper": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["UpperLetters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/castFn",
          "kind": "named",
          "namedImports": ["castFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is",
          "kind": "default",
          "default": "is",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/letters/upper.ts",
      "text": "import type { UpperLetters } from '../../../../globals/types';\nimport { castFn } from '../../../../globals/utils/castFn';\nimport is from './is';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = castFn<UpperLetters>()({\n  is: (value: unknown): value is UpperLetters => {\n    return (\n      typeof value === 'string' &&\n      is(value) &&\n      value === value.toUpperCase()\n    );\n  },\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.splitBy": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["SplitStringBy"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/splitBy.ts",
      "text": "import type { SplitStringBy } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const S extends string, By extends string = '.'>(\n  value: S,\n  by = '.' as By,\n) => {\n  const out = value.split(by);\n  return _unknown<SplitStringBy<S, By>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.startsWith": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/is/_default",
          "kind": "named",
          "namedImports": ["isTypeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/startsWith.ts",
      "text": "import { isTypeFn } from '../../../globals/utils/is/_default';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <U extends string>(\n  value: unknown,\n  prefix: U,\n): value is `${U}${string}` => {\n  return isTypeFn('string')(value) && value.startsWith(prefix);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.toLowerCase": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/toLowerCase.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends string>(value: T) => {\n  const out = value.toLowerCase();\n  return _unknown<Lowercase<T>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.toUpperCase": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/castings/toUpperCase.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends string>(value: T) => {\n  const out = value.toUpperCase();\n  return _unknown<Uppercase<T>>(out);\n};\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.castings.type": {
      "imports": [],
      "relativePath": "features/strings/castings/type.ts",
      "text": "/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = String;\n\nexport default fn;\n",
      "exports": []
    },
    "features.strings.constants": {
      "imports": [],
      "relativePath": "features/strings/constants.ts",
      "text": "/**\n * ENGLISH_LETTERS variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ENGLISH_LETTERS = [\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n] as const;\n\n/**\n * DEFAULT_DELIMITER variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const DEFAULT_DELIMITER = '.';\n",
      "exports": []
    },
    "features.strings.index": {
      "imports": [],
      "relativePath": "features/strings/index.ts",
      "text": "export * from './castings/all';\nexport * as CONSTANTS from './constants';\nexport * from './types';\nexport * from './typings/all';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castings/all';",
          "moduleSpecifier": "./castings/all"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * as CONSTANTS from './constants';",
          "moduleSpecifier": "./constants"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typings/all';",
          "moduleSpecifier": "./typings/all"
        }
      ]
    },
    "features.strings.types": {
      "imports": [
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": ["ENGLISH_LETTERS"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/strings/types.ts",
      "text": "import type { ENGLISH_LETTERS } from './constants';\n\n/**\n * LowerLetters type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type LowerLetters = (typeof ENGLISH_LETTERS)[number];\n\n/**\n * UpperLetters type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type UpperLetters = Uppercase<LowerLetters>;\n\n/**\n * Letters type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Letters = UpperLetters | LowerLetters;\n\n// export type StringLocalLitterals = Letters | Digit;\n\n/**\n * Email type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Email = `${string}@${string}.${string}`;\n\n/**\n * _JoinStringHelper type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type _JoinStringHelper = string | number | boolean | bigint;\n\n/**\n * JoinString type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type JoinString<\n  T extends readonly string[],\n  sep extends string = ' ',\n> = T extends []\n  ? ''\n  : T extends [_JoinStringHelper]\n    ? `${T[0]}`\n    : T extends [_JoinStringHelper, ...infer U extends readonly string[]]\n      ? `${T[0]}${sep}${JoinString<U, sep>}`\n      : string;\n\n/**\n * AddString type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type AddString<\n  T,\n  Before extends string = '',\n  After extends string = '',\n> = `${Before}${T & string}${After}`;\n\n/**\n * StringEndWith type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type StringEndWith<\n  S extends string,\n  E extends string,\n> = S extends `${infer Prev}${E}`\n  ? { response: true; full: S; prev: Prev }\n  : { response: false; full: S; prev: S };\n\n/**\n * StringStartWith type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type StringStartWith<\n  S extends string,\n  E extends string,\n> = S extends `${E}${infer Next}`\n  ? { response: true; full: S; next: Next }\n  : { response: false; full: S; next: S };\n\n/**\n * StringContains type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type StringContains<\n  S extends string,\n  E extends string,\n> = S extends `${infer Prev}${E}${infer Next}`\n  ? { response: true; full: S; prev: Prev; next: Next }\n  : { response: false; full: S; prev: string; next: string };\n\n/**\n * Credit to {@link https://stackoverflow.com/a/70831818/11704485 | Matthieu Riegler}\n */\n/**\n * SplitStringBy type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type SplitStringBy<\n  S extends string,\n  By extends string = '.',\n> = string extends S\n  ? string[]\n  : S extends ''\n    ? []\n    : S extends `${infer T}${By}${infer U}`\n      ? [T, ...SplitStringBy<U, By>]\n      : [S];\n\n/**\n * ExtractS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ExtractS<T> = Extract<T, string>;\n\n    ",
      "exports": []
    },
    "features.strings.typings.add": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["AddString"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/add.ts",
      "text": "import type { AddString } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends string, Before extends string, After extends string>(\n  _?: T,\n  __?: Before,\n  ___?: After,\n) => _unknown<AddString<T, Before, After>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./add",
          "kind": "default",
          "default": "add",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./contains",
          "kind": "default",
          "default": "contains",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./email",
          "kind": "default",
          "default": "email",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./endsWith",
          "kind": "default",
          "default": "endsWith",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./getLength",
          "kind": "default",
          "default": "getLength",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./includes",
          "kind": "default",
          "default": "includes",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./index",
          "kind": "default",
          "default": "_index",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./instance",
          "kind": "default",
          "default": "instance",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./join",
          "kind": "default",
          "default": "join",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./letters/all",
          "kind": "default",
          "default": "letters",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./splitBy",
          "kind": "default",
          "default": "splitBy",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./startsWith",
          "kind": "default",
          "default": "startsWith",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./toLowerCase",
          "kind": "default",
          "default": "toLowerCase",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./toUpperCase",
          "kind": "default",
          "default": "toUpperCase",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/all.ts",
      "text": "import { expandFn } from '../../../globals/utils/expandFn';\nimport add from './add';\nimport contains from './contains';\nimport email from './email';\nimport endsWith from './endsWith';\nimport getLength from './getLength';\nimport includes from './includes';\nimport _index from './index';\nimport instance from './instance';\nimport join from './join';\nimport letters from './letters/all';\nimport splitBy from './splitBy';\nimport startsWith from './startsWith';\nimport toLowerCase from './toLowerCase';\nimport toUpperCase from './toUpperCase';\n\n/**\n * typings variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typings = expandFn(_index, {\n  add,\n  contains,\n  email,\n  endsWith,\n  getLength,\n  includes,\n  instance,\n  join,\n  letters,\n  splitBy,\n  startsWith,\n  toLowerCase,\n  toUpperCase,\n});\n\n    ",
      "exports": []
    },
    "features.strings.typings.contains": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/contains.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends string, U extends string[]>(_?: T, ...__: U) =>\n  _unknown<T extends `${string}${U[number]}${string}` ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.email": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Email"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/email.ts",
      "text": "import type { Email } from '../../../globals/types';\nimport { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Email>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.endsWith": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/endsWith.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends string, U extends string>(_?: T, __?: U) =>\n  _unknown<T extends `${string}${U}` ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.getLength": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/getLength.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends string>(_?: T) => _unknown<T['length']>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.includes": {
      "imports": [
        {
          "moduleSpecifier": "./contains",
          "kind": "default",
          "default": "contains",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/includes.ts",
      "text": "import contains from './contains';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = contains;\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/index.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<string>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.instance": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/instance.ts",
      "text": "import { typeFn } from '../../../globals/utils/typeFn';\n\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<String>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.join": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["JoinString"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/join.ts",
      "text": "import type { JoinString } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <T extends readonly string[], sep extends string = ' '>(\n  _?: sep,\n  ...__: T\n) => _unknown<JoinString<T, sep>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.letters.all": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Letters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./lower",
          "kind": "default",
          "default": "lower",
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./upper",
          "kind": "default",
          "default": "upper",
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/letters/all.ts",
      "text": "import type { Letters } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\nimport lower from './lower';\nimport upper from './upper';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Letters>()({\n  lower,\n  upper,\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.letters.index": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Letters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/letters/index.ts",
      "text": "import type { Letters } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<Letters>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.letters.lower": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["LowerLetters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/letters/lower.ts",
      "text": "import type { LowerLetters } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<LowerLetters>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.letters.type": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["Letters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/letters/type.ts",
      "text": "import type { Letters } from '../../../../globals/types';\nimport { _unknown } from '../../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = _unknown<Letters>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.letters.upper": {
      "imports": [
        {
          "moduleSpecifier": "../../../../globals/types",
          "kind": "named",
          "namedImports": ["UpperLetters"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../../globals/utils/typeFn",
          "kind": "named",
          "namedImports": ["typeFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/letters/upper.ts",
      "text": "import type { UpperLetters } from '../../../../globals/types';\nimport { typeFn } from '../../../../globals/utils/typeFn';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = typeFn<UpperLetters>()();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.splitBy": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["SplitStringBy"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/splitBy.ts",
      "text": "import type { SplitStringBy } from '../../../globals/types';\nimport { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const S extends string, By extends string = '.'>(\n  _?: S,\n  __?: By,\n) => _unknown<SplitStringBy<S, By>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.startsWith": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/startsWith.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends string, U extends string>(_?: T, __?: U) =>\n  _unknown<T extends `${U}${string}` ? true : false>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.toLowerCase": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/toLowerCase.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends string>(_?: T) => _unknown<Lowercase<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.strings.typings.toUpperCase": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/utils/_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/strings/typings/toUpperCase.ts",
      "text": "import { _unknown } from '../../../globals/utils/_unknown';\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = <const T extends string>(_?: T) => _unknown<Uppercase<T>>();\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.transform.constants": {
      "imports": [],
      "relativePath": "features/transform/constants.ts",
      "text": "/**\n * PRIMITIVES variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PRIMITIVES = [\n  'string',\n  'number',\n  'boolean',\n  'bigint',\n  'symbol',\n  'undefined',\n  'null',\n] as const;\n\n/**\n * PRIMITIVE_OBJECTS variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PRIMITIVE_OBJECTS = ['date', 'primitive'] as const;\n/**\n * MAYBE variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const MAYBE = '$$app-ts => maybe$$' as const;\n/**\n * CUSTOM variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const CUSTOM = '$$app-ts => custom$$' as const;\n/**\n * PARTIAL variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const PARTIAL = '$$app-ts => partial$$' as const;\n/**\n * ARRAY variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const ARRAY = '$$app-ts => array$$' as const;\n",
      "exports": []
    },
    "features.transform.helpers.any": {
      "imports": [
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["ObjectS"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/any.ts",
      "text": "import type { ObjectS } from '../types';\n\n/**\n * any const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst any = <T extends ObjectS = ObjectS>(value?: T) => value as T;\nexport default any;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.array": {
      "imports": [
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": ["ARRAY"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["__ObjectS", "ArrayCustom", "Maybe"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/array.ts",
      "text": "import { ARRAY } from '../constants';\nimport type { __ObjectS, ArrayCustom, Maybe } from '../types';\n\n/**\n * array const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst array = <T extends __ObjectS | Maybe>(value: T) =>\n  ({ [ARRAY]: value }) as ArrayCustom<T>;\n\nexport default array;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.custom": {
      "imports": [
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": ["CUSTOM"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["Custom"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/custom.ts",
      "text": "import { CUSTOM } from '../constants';\nimport type { Custom } from '../types';\n\n/**\n * custom const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst custom = <T = any>(value?: T) =>\n  ({\n    [CUSTOM]: value,\n  }) as Custom<T>;\n\nexport default custom;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.index": {
      "imports": [],
      "relativePath": "features/transform/helpers/index.ts",
      "text": "export { default as any } from './any';\nexport { default as array } from './array';\nexport { default as custom } from './custom';\nexport { default as intersection } from './intersection';\nexport { default as litterals } from './litterals';\nexport { default as maybe } from './maybe';\nexport { default as partial } from './partial';\nexport { default as record } from './record';\nexport { default as soa } from './soa';\nexport { default as sora } from './sora';\nexport { default as sv } from './sv';\nexport { default as tuple } from './tuple';\nexport { default as union } from './union';\n",
      "exports": [
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as any } from './any';",
          "moduleSpecifier": "./any"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as array } from './array';",
          "moduleSpecifier": "./array"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as custom } from './custom';",
          "moduleSpecifier": "./custom"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as intersection } from './intersection';",
          "moduleSpecifier": "./intersection"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as litterals } from './litterals';",
          "moduleSpecifier": "./litterals"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as maybe } from './maybe';",
          "moduleSpecifier": "./maybe"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as partial } from './partial';",
          "moduleSpecifier": "./partial"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as record } from './record';",
          "moduleSpecifier": "./record"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as soa } from './soa';",
          "moduleSpecifier": "./soa"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as sora } from './sora';",
          "moduleSpecifier": "./sora"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as sv } from './sv';",
          "moduleSpecifier": "./sv"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as tuple } from './tuple';",
          "moduleSpecifier": "./tuple"
        },
        {
          "name": "default",
          "kind": "named",
          "text": "export { default as union } from './union';",
          "moduleSpecifier": "./union"
        }
      ]
    },
    "features.transform.helpers.intersection": {
      "imports": [
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["ObjectMapS"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/intersection.ts",
      "text": "import type { ObjectMapS } from '../types';\n\ntype _IntersectionCustom<T extends ObjectMapS[]> = T extends [\n  infer First extends ObjectMapS,\n  ...infer Rest extends ObjectMapS[],\n]\n  ? First & IntersectionCustom<Rest>\n  : unknown;\n\n/**\n * IntersectionCustom type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type IntersectionCustom<T extends ObjectMapS[]> =\n  _IntersectionCustom<T> extends infer R\n    ? {\n        [K in keyof R]: R[K];\n      }\n    : never;\n\n/**\n * intersection const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst intersection = <T extends [ObjectMapS, ObjectMapS, ...ObjectMapS[]]>(\n  ...values: T\n) => {\n  const out = values.reduce((acc, curr) => {\n    Object.entries(curr).forEach(([key, value]) => {\n      acc[key] = value;\n    });\n    return acc;\n  }, {} as any);\n  return out as IntersectionCustom<T>;\n};\n\nexport default intersection;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.litterals": {
      "imports": [
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["Custom"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/litterals.ts",
      "text": "import type { Custom } from '../types';\n\n/**\n * litterals const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst litterals = <const T extends (string | number | boolean)[]>(\n  ...values: T\n) => values[0] as unknown as Custom<T[number]>;\n\nexport default litterals;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.maybe": {
      "imports": [
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": ["MAYBE"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["__ObjectS", "Maybe"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/maybe.ts",
      "text": "import { MAYBE } from '../constants';\nimport type { __ObjectS, Maybe } from '../types';\n\n/**\n * maybe const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst maybe = <T extends __ObjectS | __ObjectS[]>(value?: T) =>\n  ({\n    [MAYBE]: value,\n  }) as Maybe<T>;\n\nexport default maybe;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.partial": {
      "imports": [
        {
          "moduleSpecifier": "../constants",
          "kind": "named",
          "namedImports": ["PARTIAL"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["ObjectS", "PartialCustom"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/partial.ts",
      "text": "import { PARTIAL } from '../constants';\nimport type { ObjectS, PartialCustom } from '../types';\n\n/**\n * partial const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst partial = <T extends ObjectS>(value: T): T & PartialCustom => {\n  const entries = Object.entries(value).filter(([key]) => key !== PARTIAL);\n  const out: any = {};\n\n  entries.forEach(([key, value]) => {\n    out[key] = value;\n  });\n\n  return out;\n};\n\nexport default partial;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.record": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys", "PrimitiveObject"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/record.ts",
      "text": "import type { Keys, PrimitiveObject } from '../../../globals/types';\n\n/**\n * record const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst record = <const K extends Keys[], V extends PrimitiveObject>(\n  value: V,\n  ...keys: K\n) => {\n  const object = keys.reduce((acc, key) => {\n    acc[key] = value;\n    return acc;\n  }, {} as any);\n\n  return object as Record<K[number] extends never ? Keys : K[number], V>;\n};\n\nexport default record;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.soa": {
      "imports": [
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["ObjectS"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["SoA"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/soa.ts",
      "text": "import type { ObjectS } from '../types';\nimport type { SoA } from '../../../globals/types';\n\n/**\n * soa const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst soa = <T extends ObjectS>(value: T) => {\n  return value as SoA<T>;\n};\n\nexport default soa;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.sora": {
      "imports": [
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["ObjectS"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["SoRa"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/sora.ts",
      "text": "import type { ObjectS } from '../types';\nimport type { SoRa } from '../../../globals/types';\n\n/**\n * sora const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst sora = <T extends ObjectS>(value: T) => {\n  return value as SoRa<T>;\n};\n\nexport default sora;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.sv": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["StateValue"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["Custom"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/sv.ts",
      "text": "import type { StateValue } from '../../../globals/types';\nimport type { Custom } from '../types';\n\n/**\n * sv const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst sv = {} as Custom<StateValue>;\nexport default sv;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.tuple": {
      "imports": [
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["__ObjectS", "ArrayCustom", "Maybe"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/tuple.ts",
      "text": "import type { __ObjectS, ArrayCustom, Maybe } from '../types';\n\n/**\n * tuple const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst tuple = <\n  T extends [\n    __ObjectS | Maybe | ArrayCustom,\n    ...(__ObjectS | Maybe | ArrayCustom)[],\n  ],\n>(\n  ...values: T\n) => values;\n\nexport default tuple;\n\n    ",
      "exports": []
    },
    "features.transform.helpers.union": {
      "imports": [
        {
          "moduleSpecifier": "../../../globals/types",
          "kind": "named",
          "namedImports": ["Keys", "PrimitiveObjectMap"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../../globals/utils/expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["ObjectS"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/helpers/union.ts",
      "text": "import type { Keys, PrimitiveObjectMap } from '../../../globals/types';\nimport { expandFn } from '../../../globals/utils/expandFn';\nimport type { ObjectS } from '../types';\n\nconst union = <T extends [ObjectS, ObjectS, ...ObjectS[]]>(\n  ...values: T\n) => {\n  return values[0] as T[number];\n};\n\ntype Discriminated<K extends Keys> = PrimitiveObjectMap &\n  Record<K, ObjectS>;\n\n/**\n * fn const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nconst fn = expandFn(union, {\n  discriminated: <\n    const K extends Keys,\n    T extends [Discriminated<K>, Discriminated<K>, ...Discriminated<K>[]],\n  >(\n    _key: K,\n    ...values: T\n  ) => union(...values),\n});\n\nexport default fn;\n\n    ",
      "exports": []
    },
    "features.transform.index": {
      "imports": [],
      "relativePath": "features/transform/index.ts",
      "text": "export * from './constants';\nexport * from './helpers';\nexport * from './transform';\nexport * from './types';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './constants';",
          "moduleSpecifier": "./constants"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './helpers';",
          "moduleSpecifier": "./helpers"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './transform';",
          "moduleSpecifier": "./transform"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './types';",
          "moduleSpecifier": "./types"
        }
      ]
    },
    "features.transform.transform": {
      "imports": [
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": ["CUSTOM", "MAYBE", "PARTIAL"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "any",
            "array",
            "custom",
            "intersection",
            "litterals",
            "maybe",
            "partial",
            "record",
            "soa",
            "sora",
            "sv",
            "tuple",
            "union"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./transform.types",
          "kind": "named",
          "namedImports": ["Transform_F"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["inferT", "ObjectS", "TransformTypes", "Types"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/transform.ts",
      "text": "import { CUSTOM, MAYBE, PARTIAL } from './constants';\nimport { any, array, custom, intersection, litterals, maybe, partial, record, soa, sora, sv, tuple, union } from './helpers';\nimport type { Transform_F } from './transform.types';\nimport type { inferT, ObjectS, TransformTypes, Types } from './types';\n\nconst transformTypes = <T extends Types>(type: T): TransformTypes<T> => {\n  const out: any = type === 'primitive' ? {} : undefined;\n  return out;\n};\n\nconst _transform = <T extends ObjectS>(obj: T): inferT<T> => {\n  const _obj = obj as any;\n\n  const checkArray = Array.isArray(obj);\n  if (checkArray) {\n    return obj.map(_transform as any) as any;\n  }\n\n  const checkObject = typeof obj === 'object';\n  if (checkObject) {\n    if (MAYBE in _obj) {\n      return _transform(_obj[MAYBE]);\n    }\n\n    const isCustom = Object.keys(obj).every(key => key === CUSTOM);\n    const out: any = {};\n    if (isCustom) return out;\n\n    const entries = Object.entries(obj).filter(([key]) => key !== PARTIAL);\n\n    entries.forEach(([key, value]) => {\n      out[key] = _transform(value);\n    });\n\n    return out;\n  }\n\n  return transformTypes(_obj) as any;\n};\n\n/**\n * transform variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const transform: Transform_F = option => {\n  const objectS = option({\n    any,\n    custom,\n    intersection,\n    litterals,\n    maybe,\n    partial,\n    record,\n    soa,\n    sora,\n    sv,\n    union,\n    array,\n    tuple,\n  });\n\n  return _transform(objectS);\n};\n\n    ",
      "exports": []
    },
    "features.transform.transform.types": {
      "imports": [
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "any",
            "custom",
            "intersection",
            "litterals",
            "maybe",
            "partial",
            "record",
            "soa",
            "sora",
            "sv",
            "union",
            "array",
            "tuple"
          ],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./types",
          "kind": "named",
          "namedImports": ["ObjectS", "TransformS"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/transform.types.ts",
      "text": "import type { any, custom, intersection, litterals, maybe, partial, record, soa, sora, sv, union, array, tuple } from './helpers';\nimport type { ObjectS, TransformS } from './types';\n\n/**\n * Helpers type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Helpers = {\n  any: typeof any;\n  custom: typeof custom;\n  intersection: typeof intersection;\n  litterals: typeof litterals;\n  maybe: typeof maybe;\n  partial: typeof partial;\n  record: typeof record;\n  soa: typeof soa;\n  sora: typeof sora;\n  sv: typeof sv;\n  union: typeof union;\n  array: typeof array;\n  tuple: typeof tuple;\n};\n\n/**\n * Transform_F type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Transform_F = <T extends ObjectS = ObjectS>(\n  option: (helpers: Helpers) => T,\n) => TransformS<T>;\n\n    ",
      "exports": []
    },
    "features.transform.types": {
      "imports": [
        {
          "moduleSpecifier": "../../globals/types",
          "kind": "named",
          "namedImports": ["AnyArray", "Keys", "NOmit", "Ru", "SoRa"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./constants",
          "kind": "named",
          "namedImports": [
            "ARRAY",
            "CUSTOM",
            "MAYBE",
            "PARTIAL",
            "PRIMITIVES",
            "PRIMITIVE_OBJECTS"
          ],
          "isTypeOnly": true
        }
      ],
      "relativePath": "features/transform/types.ts",
      "text": "import type { AnyArray, Keys, NOmit, Ru, SoRa } from '../../globals/types';\nimport type { ARRAY, CUSTOM, MAYBE, PARTIAL, PRIMITIVES, PRIMITIVE_OBJECTS } from './constants';\n\n/**\n * PrimitiveS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PrimitiveS = (typeof PRIMITIVES)[number];\ntype TransformPrimitiveS<T extends PrimitiveS> = T extends 'string'\n  ? string\n  : T extends 'number'\n    ? number\n    : T extends 'boolean'\n      ? boolean\n      : T extends 'null'\n        ? null\n        : T extends 'undefined'\n          ? undefined\n          : T extends 'symbol'\n            ? symbol\n            : never;\n\n/**\n * Types type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Types = PrimitiveS | (typeof PRIMITIVE_OBJECTS)[number];\n\n/**\n * TransformTypes type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TransformTypes<T extends Types> = T extends PrimitiveS\n  ? TransformPrimitiveS<T>\n  : T extends 'date'\n    ? Date\n    : // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n      {};\n\n/**\n * Custom type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Custom<T = any> = {\n  [CUSTOM]: T;\n};\n\n/**\n * PartialCustom type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type PartialCustom = {\n  [PARTIAL]: undefined;\n};\n\n/**\n * __ObjectS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type __ObjectS = Types | ObjectMapS | Custom | PartialCustom;\n\n/**\n * Maybe type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type Maybe<\n  T extends __ObjectS | ArrayCustom | __ObjectS[] = __ObjectS,\n> = {\n  [MAYBE]: T;\n};\n\n/**\n * ArrayCustom type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ArrayCustom<T extends __ObjectS | Maybe = __ObjectS> = {\n  [ARRAY]: T;\n};\n\n/**\n * ObjectMapS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ObjectMapS = {\n  [key: Keys]: SoRa<_ObjectS>;\n};\n\ntype _ObjectS = __ObjectS | Maybe | ArrayCustom;\n\n/**\n * A type that represents a primitive object, which can be a primitive value or an object\n *\n * @remark\n */\n/**\n * ObjectS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type ObjectS = _ObjectS | SoRa<_ObjectS>;\n/**\n * POS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type POS = ObjectS;\n\ntype ReduceTuple2<T extends AnyArray<ObjectS>> = T extends [\n  infer First,\n  ...infer Rest extends AnyArray<ObjectS>,\n]\n  ? [TransformS<First>, ...ReduceTuple2<Rest>]\n  : T extends AnyArray<infer A extends ObjectS>\n    ? TransformS<A>[]\n    : [];\n\ntype __TransformPrimitiveObject<T> = T extends Types\n  ? TransformTypes<T>\n  : T extends Custom<infer TCustom>\n    ? TCustom\n    : T extends AnyArray<ObjectS>\n      ? ReduceTuple2<T>\n      : T extends ArrayCustom<infer A>\n        ? TransformS<A>[]\n        : T extends PartialCustom\n          ? Partial<__TransformPrimitiveObject<NOmit<T, typeof PARTIAL>>>\n          : T extends Maybe<infer TMaybe>\n            ? __TransformPrimitiveObject<TMaybe> | undefined\n            : {\n                [K in keyof T]: __TransformPrimitiveObject<T[K]>;\n              };\n\ntype ReduceTupleU<T extends AnyArray> = T extends [\n  infer First,\n  ...infer Rest extends AnyArray,\n]\n  ? [Undefiny<First>, ...ReduceTupleU<Rest>]\n  : T[number] extends never\n    ? []\n    : T['length'] extends 0\n      ? []\n      : number extends T['length']\n        ? T\n        : Undefiny<T[number]>[];\ntype HasUndefined<T> = undefined extends T ? true : false;\ntype UndefinyObject<T extends object> = {\n  [K in keyof T as HasUndefined<T[K]> extends true ? never : K]: Undefiny<\n    T[K]\n  >;\n} & {\n  [K in keyof T as HasUndefined<T[K]> extends true ? K : never]?: Undefiny<\n    Exclude<T[K], undefined>\n  >;\n} extends infer F\n  ? {\n      [K in keyof F]: F[K];\n    }\n  : never;\n\ntype Undefiny<T> = T extends AnyArray\n  ? ReduceTupleU<T>\n  : T extends Ru\n    ? UndefinyObject<T>\n    : T;\n/**\n * TransformS type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type TransformS<T> = Undefiny<__TransformPrimitiveObject<T>>;\n\n/**\n * inferT type - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport type inferT<T extends ObjectS> = TransformS<T>;\n\n    ",
      "exports": []
    },
    "features.typescript.extractFromFile": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": ["Node", "Project", "SyntaxKind"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./findFirstCallExpression",
          "kind": "named",
          "namedImports": ["findFirstCallExpression"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./helpers",
          "kind": "named",
          "namedImports": [
            "extractExportsRecursively",
            "resolveModuleSpecifier"
          ],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./parseObject",
          "kind": "named",
          "namedImports": ["parseObject"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./resolveType",
          "kind": "named",
          "namedImports": ["resolveType"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/typescript/extractFromFile.ts",
      "text": "import { Node, Project, SyntaxKind } from 'ts-morph';\nimport { findFirstCallExpression } from './findFirstCallExpression';\nimport { extractExportsRecursively, resolveModuleSpecifier } from './helpers';\nimport { parseObject } from './parseObject';\nimport { resolveType } from './resolveType';\n\n/**\n * extractFromFile variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractFromFile = (filePath: string) => {\n  const project = new Project({\n    tsConfigFilePath: 'tsconfig.json',\n  });\n  const sourceFile = project.addSourceFileAtPath(filePath);\n\n  // Fonction pour résoudre les spécificateurs de modules en utilisant tsconfig.json\n\n  // Fonction pour résoudre récursivement les types importés en utilisant l'API du compilateur\n\n  const out = {\n    exports: extractExportsRecursively(project, sourceFile),\n\n    imports: sourceFile.getImportDeclarations().map(imp => ({\n      moduleSpecifier: resolveModuleSpecifier(\n        project,\n        imp.getModuleSpecifierValue(),\n      ),\n      namedImports: imp.getNamedImports().map(named => named.getName()),\n    })),\n\n    types: sourceFile.getTypeAliases().map(type => ({\n      name: type.getName(),\n      typeParameters: type.getTypeParameters().map(tp => tp.getName()),\n      type: type.getTypeNodeOrThrow().getText(),\n    })),\n\n    variables: sourceFile.getVariableDeclarations().map(v => {\n      const initializer = v.getInitializer();\n      let params: any[] = [];\n      let firstFunctionName: string | undefined;\n\n      const isCallable1 = Node.isCallExpression(initializer);\n\n      // Fonction pour trouver le premier appel de fonction dans une chaîne\n\n      // Vérifier si l'initializer est un appel de fonction\n      if (isCallable1) {\n        // Trouver le premier appel de fonction dans la chaîne\n        const firstCallExpression = findFirstCallExpression(initializer);\n\n        const isCallable2 = Node.isCallExpression(firstCallExpression);\n\n        if (isCallable2) {\n          // Récupérer le nom de la fonction\n          const expression = firstCallExpression.getExpression();\n          if (expression.getKind() === SyntaxKind.Identifier) {\n            firstFunctionName = expression.getText();\n          }\n\n          params = firstCallExpression.getArguments().map(arg => {\n            if (Node.isCallExpression(arg)) {\n              // Si c'est un appel de fonction, extraire le type de retour\n              const type = arg.getType();\n              return resolveType(sourceFile, type);\n            }\n\n            const text = arg.getText();\n            if (Node.isObjectLiteralExpression(arg))\n              return parseObject(text);\n\n            return text;\n          });\n        }\n      }\n\n      return {\n        name: v.getName(),\n        // Type node (ce qui est écrit dans le code)\n        // Nom de la première fonction appelée\n        function: firstFunctionName,\n        // Arguments de l'appel de fonction si applicable\n        params,\n        // Flags du type\n      };\n    }),\n  };\n\n  project.removeSourceFile(sourceFile);\n\n  return out;\n};\n\n    ",
      "exports": []
    },
    "features.typescript.findFirstCallExpression": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": ["Node"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/typescript/findFirstCallExpression.ts",
      "text": "import { Node } from 'ts-morph';\n\n/**\n * findFirstCallExpression variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const findFirstCallExpression = (node: Node): any => {\n  const hasExpression = Node.hasExpression(node);\n  if (hasExpression) {\n    const expression = node.getExpression();\n\n    // Si l'expression est un PropertyAccessExpression (e.g., createMachine(...).provideOptions)\n    if (\n      expression &&\n      // expression.getKind() === SyntaxKind.PropertyAccessExpression &&\n      Node.hasExpression(expression)\n    ) {\n      // Récursivement chercher dans l'expression de gauche\n      // Cast to PropertyAccessExpression to access getExpression()\n      return findFirstCallExpression(expression.getExpression());\n    }\n\n    // Si c'est un Identifier ou autre, c'est le premier appel\n    return node;\n  }\n\n  return node;\n};\n\n    ",
      "exports": []
    },
    "features.typescript.helpers": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": ["Project", "SourceFile"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": ["Node"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/typescript/helpers.ts",
      "text": "import type { Project, SourceFile } from 'ts-morph';\nimport { Node } from 'ts-morph';\n\n/**\n * resolveModuleSpecifier variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const resolveModuleSpecifier = (\n  project: Project,\n  moduleSpecifier: string,\n): string => {\n  try {\n    // Obtenir les options du compilateur du projet\n    const compilerOptions = project.getCompilerOptions();\n    const baseUrl = compilerOptions.baseUrl;\n    const paths = compilerOptions.paths;\n\n    // Si on a un chemin relatif simple, le retourner tel quel\n    if (\n      moduleSpecifier.startsWith('./') ||\n      moduleSpecifier.startsWith('../')\n    ) {\n      return moduleSpecifier;\n    }\n\n    // Si on a des chemins définis dans tsconfig, essayer de les résoudre\n    if (paths && baseUrl) {\n      for (const [pathPattern, pathMappings] of Object.entries(paths)) {\n        // Enlever l'astérisque pour la comparaison\n        const patternBase = pathPattern.replace('/*', '');\n\n        if (moduleSpecifier.startsWith(patternBase)) {\n          // Remplacer le préfixe par le chemin réel\n          const suffix = moduleSpecifier.slice(patternBase.length);\n          const mappingBase = pathMappings[0]?.replace('/*', '') || '';\n          return `${mappingBase}${suffix}`;\n        }\n      }\n    }\n\n    // Sinon, retourner le spécificateur original\n    return moduleSpecifier;\n  } catch {\n    // En cas d'erreur, retourner le spécificateur original\n    return moduleSpecifier;\n  }\n};\n\n// Fonction pour extraire récursivement les exports\n/**\n * extractExportsRecursively variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const extractExportsRecursively = (\n  project: Project,\n  sourceFile: SourceFile,\n  visited = new Set<string>(),\n): any => {\n  const filePath = sourceFile.getFilePath();\n\n  // Éviter les cycles infinis\n  if (visited.has(filePath)) {\n    return [];\n  }\n  visited.add(filePath);\n\n  const exports: any[] = [];\n\n  // Traiter toutes les déclarations d'export\n  for (const [\n    name,\n    declarations,\n  ] of sourceFile.getExportedDeclarations()) {\n    for (const declaration of declarations) {\n      const declarationSourceFile = declaration.getSourceFile();\n\n      // Si la déclaration vient d'un autre fichier, extraire récursivement\n      if (declarationSourceFile.getFilePath() !== filePath) {\n        const recursiveExports = extractExportsRecursively(\n          project,\n          declarationSourceFile,\n          visited,\n        );\n\n        // Extraire tous les imports du fichier source de la déclaration\n        const fileImports = declarationSourceFile\n          .getImportDeclarations()\n          .map(imp => ({\n            moduleSpecifier: resolveModuleSpecifier(\n              project,\n              imp.getModuleSpecifierValue(),\n            ),\n            namedImports: imp\n              .getNamedImports()\n              .map(named => named.getName()),\n            defaultImport: imp.getDefaultImport()?.getText(),\n            namespaceImport: imp.getNamespaceImport()?.getText(),\n          }));\n\n        exports.push({\n          name,\n          type: 'recursive',\n          imports: fileImports, // Ajouter les imports comme exports\n          filePath: declarationSourceFile.getFilePath(),\n          declarations: recursiveExports,\n        });\n      } else {\n        // Traiter les différents types de déclarations\n        const declarationInfo: any = {\n          name,\n          type: declaration.getKindName(),\n        };\n\n        // Traitement spécifique selon le type de déclaration\n        if (Node.isVariableDeclaration(declaration)) {\n          const initializer = declaration.getInitializer();\n          declarationInfo.hasInitializer = !!initializer;\n          if (initializer) {\n            declarationInfo.initializerText = initializer.getText();\n          }\n        } else if (Node.isFunctionDeclaration(declaration)) {\n          declarationInfo.parameters = declaration\n            .getParameters()\n            .map(p => ({\n              name: p.getName(),\n              type: p.getTypeNode()?.getText(),\n            }));\n          declarationInfo.returnType = declaration\n            .getReturnTypeNode()\n            ?.getText();\n        } else if (Node.isClassDeclaration(declaration)) {\n          declarationInfo.extends = declaration.getExtends()?.getText();\n          declarationInfo.implements = declaration\n            .getImplements()\n            .map(i => i.getText());\n          declarationInfo.properties = declaration\n            .getProperties()\n            .map(p => ({\n              name: p.getName(),\n              type: p.getTypeNode()?.getText(),\n            }));\n        } else if (Node.isInterfaceDeclaration(declaration)) {\n          declarationInfo.extends = declaration\n            .getExtends()\n            .map(e => e.getText());\n          declarationInfo.properties = declaration\n            .getProperties()\n            .map(p => ({\n              name: p.getName(),\n              type: p.getTypeNode()?.getText(),\n            }));\n        } else if (Node.isTypeAliasDeclaration(declaration)) {\n          declarationInfo.typeParameters = declaration\n            .getTypeParameters()\n            .map(tp => tp.getName());\n          declarationInfo.typeDefinition = declaration\n            .getTypeNode()\n            ?.getText();\n        } else if (Node.isExportDeclaration(declaration)) {\n          // Gérer les re-exports (export * from './module')\n          const moduleSpecifier = declaration.getModuleSpecifier();\n          if (moduleSpecifier) {\n            const targetFile = declaration.getModuleSpecifierSourceFile();\n            if (targetFile) {\n              const recursiveExports = extractExportsRecursively(\n                project,\n                targetFile,\n                visited,\n              );\n              declarationInfo.reExports = recursiveExports;\n              declarationInfo.moduleSpecifier = resolveModuleSpecifier(\n                project,\n                moduleSpecifier.getLiteralValue(),\n              );\n            }\n          }\n        }\n\n        exports.push(declarationInfo);\n      }\n    }\n  }\n\n  return exports;\n};\n\n    ",
      "exports": []
    },
    "features.typescript.index": {
      "imports": [],
      "relativePath": "features/typescript/index.ts",
      "text": "export { extractFromFile } from './extractFromFile';\nexport { findFirstCallExpression } from './findFirstCallExpression';\nexport { parseObject } from './parseObject';\nexport { resolveType } from './resolveType';\n",
      "exports": [
        {
          "name": "extractFromFile",
          "kind": "named",
          "text": "export { extractFromFile } from './extractFromFile';",
          "moduleSpecifier": "./extractFromFile"
        },
        {
          "name": "findFirstCallExpression",
          "kind": "named",
          "text": "export { findFirstCallExpression } from './findFirstCallExpression';",
          "moduleSpecifier": "./findFirstCallExpression"
        },
        {
          "name": "parseObject",
          "kind": "named",
          "text": "export { parseObject } from './parseObject';",
          "moduleSpecifier": "./parseObject"
        },
        {
          "name": "resolveType",
          "kind": "named",
          "text": "export { resolveType } from './resolveType';",
          "moduleSpecifier": "./resolveType"
        }
      ]
    },
    "features.typescript.parseObject": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": ["Node", "Project", "SyntaxKind"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/typescript/parseObject.ts",
      "text": "import { Node, Project, SyntaxKind } from 'ts-morph';\n\n/**\n * parseObject variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const parseObject = (objString: string): any => {\n  try {\n    const project = new Project();\n\n    // Créer un fichier temporaire avec l'objet\n    const tempFile = project.createSourceFile(\n      'temp.ts',\n      `\n/**\n * obj const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\n      const obj = ${objString};\n      export default obj;\n    `,\n    );\n\n    // Obtenir la déclaration de variable\n    const variableDeclaration = tempFile.getVariableDeclaration('obj');\n    if (!variableDeclaration) return null;\n\n    const initializer = variableDeclaration.getInitializer();\n    if (\n      !initializer ||\n      initializer.getKind() !== SyntaxKind.ObjectLiteralExpression\n    ) {\n      return null;\n    }\n\n    // Fonction récursive pour parser l'objet\n    const parseNode = (node: Node): any => {\n      if (Node.isObjectLiteralExpression(node)) {\n/**\n * obj const - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\n        const obj: any = {};\n        node.getProperties().forEach((prop: any) => {\n          if (Node.isPropertyAssignment(prop)) {\n            const name = prop.getName();\n            const initializer = prop.getInitializer();\n            if (initializer) {\n              const value = parseNode(initializer);\n              obj[name] = value;\n            }\n          }\n        });\n        return obj;\n      }\n\n      if (Node.isArrayLiteralExpression(node)) {\n        return node\n          .getElements()\n          .map((element: any) => parseNode(element));\n      }\n\n      if (Node.isStringLiteral(node) || Node.isNumericLiteral(node)) {\n        return node.getLiteralValue();\n      }\n\n      if (Node.isTrueLiteral(node)) {\n        return true;\n      }\n\n      if (Node.isFalseLiteral(node)) {\n        return false;\n      }\n\n      if (Node.isNullLiteral(node)) {\n        return null;\n      }\n\n      if (Node.isIdentifier(node)) {\n        return node.getText();\n      }\n\n      return node.getText();\n    };\n\n    return parseNode(initializer);\n  } catch (error) {\n    console.error('Erreur avec ts-morph:', error);\n    return null;\n  }\n};\n\n    ",
      "exports": []
    },
    "features.typescript.resolveType": {
      "imports": [
        {
          "moduleSpecifier": "ts-morph",
          "kind": "named",
          "namedImports": [
            "SymbolFlags",
            "TypeFormatFlags",
            "SourceFile",
            "Type"
          ],
          "isTypeOnly": false
        }
      ],
      "relativePath": "features/typescript/resolveType.ts",
      "text": "import { SymbolFlags, TypeFormatFlags, SourceFile, Type } from 'ts-morph';\n\n/**\n * resolveType variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const resolveType = (\n  sourceFile: SourceFile,\n  type: Type,\n): string => {\n  const typeText = type.getText();\n\n  try {\n    // Accéder au compilateur TypeScript sous-jacent\n    const compilerType = type.compilerType;\n    const typeChecker = sourceFile\n      .getProject()\n      .getTypeChecker().compilerObject;\n\n    const fullyResolvedTypeText = typeChecker.typeToString(\n      compilerType,\n      undefined,\n      TypeFormatFlags.InTypeAlias |\n        TypeFormatFlags.WriteArrayAsGenericType |\n        TypeFormatFlags.UseStructuralFallback |\n        TypeFormatFlags.NoTruncation |\n        TypeFormatFlags.WriteClassExpressionAsTypeLiteral |\n        TypeFormatFlags.InElementType,\n    );\n\n    // #region Première  tentative: Si le type résolu est structurel\n    // contient des objets et aucun import\n    if (\n      fullyResolvedTypeText !== typeText &&\n      !fullyResolvedTypeText.includes('import(') &&\n      (fullyResolvedTypeText.includes('{') ||\n        fullyResolvedTypeText.length > typeText.length * 1.5)\n    ) {\n      return fullyResolvedTypeText;\n    }\n    // #endregion\n\n    // #region Deuxième tentative: résoudre les alias et types importés\n    const symbol = compilerType.symbol;\n\n    // Pour les types aliasés (comme TransformArgs)\n    if (symbol.flags & SymbolFlags.TypeAlias) {\n      const aliasResolvedTypeText = typeChecker.typeToString(\n        compilerType,\n        undefined,\n        TypeFormatFlags.InTypeAlias |\n          TypeFormatFlags.WriteClassExpressionAsTypeLiteral |\n          TypeFormatFlags.NoTruncation,\n      );\n\n      if (\n        aliasResolvedTypeText !== typeText &&\n        !aliasResolvedTypeText.includes('import(') &&\n        aliasResolvedTypeText.includes('{')\n      ) {\n        return aliasResolvedTypeText;\n      }\n    }\n\n    // Pour les types importés, essayer de résoudre le symbole aliasé\n    if (symbol.flags & SymbolFlags.Alias) {\n      const aliasedSymbol = typeChecker.getAliasedSymbol(symbol);\n      if (aliasedSymbol && aliasedSymbol !== symbol) {\n        const aliasedType = typeChecker.getTypeOfSymbolAtLocation(\n          aliasedSymbol,\n          aliasedSymbol.declarations?.[0] || sourceFile.compilerNode,\n        );\n\n        const resolvedAliasTypeText = typeChecker.typeToString(\n          aliasedType,\n          undefined,\n          TypeFormatFlags.InTypeAlias |\n            TypeFormatFlags.WriteClassExpressionAsTypeLiteral |\n            TypeFormatFlags.NoTruncation,\n        );\n\n        if (\n          resolvedAliasTypeText !== typeText &&\n          !resolvedAliasTypeText.includes('import(') &&\n          resolvedAliasTypeText.includes('{')\n        ) {\n          return resolvedAliasTypeText;\n        }\n      }\n    }\n    // #endregion\n\n    // #region Troisième tentative: type apparent pour révéler la structure cachée\n    const apparentType = typeChecker.getApparentType(compilerType);\n\n    const apparentText = typeChecker.typeToString(\n      apparentType,\n      undefined,\n      TypeFormatFlags.InTypeAlias |\n        TypeFormatFlags.WriteClassExpressionAsTypeLiteral |\n        TypeFormatFlags.UseStructuralFallback |\n        TypeFormatFlags.NoTruncation,\n    );\n\n    if (\n      apparentText !== typeText &&\n      !apparentText.includes('import(') &&\n      (apparentText.includes('{') ||\n        apparentText.length > typeText.length * 1.2)\n    ) {\n      return apparentText;\n    }\n    // #endregion\n\n    // #region Quatrième tentative: forcer l'expansion structurelle\n    const structuralTypeText = typeChecker.typeToString(\n      compilerType,\n      undefined,\n      TypeFormatFlags.WriteClassExpressionAsTypeLiteral |\n        TypeFormatFlags.UseStructuralFallback |\n        TypeFormatFlags.InElementType |\n        TypeFormatFlags.NoTruncation,\n    );\n\n    if (\n      structuralTypeText !== typeText &&\n      structuralTypeText !== fullyResolvedTypeText &&\n      !structuralTypeText.includes('import(') &&\n      structuralTypeText.includes('{')\n    ) {\n      return structuralTypeText;\n    }\n    // #endregion\n  } catch (error) {\n    console.warn(\n      `Erreur lors de la résolution du type ${typeText} : `,\n      error,\n    );\n  }\n\n  return typeText;\n};\n\n    ",
      "exports": []
    },
    "globals.castings": {
      "imports": [],
      "relativePath": "globals/castings.ts",
      "text": "export { castings as arrays } from '../features/arrays/castings/all';\nexport { castings as common } from '../features/common/castings/all';\n// export { castings as functions } from '../features/functions/castings/all';\nexport { castings as numbers } from '../features/numbers/castings/all';\nexport { castings as objects } from '../features/objects/castings/all';\n// export { castings as promises } from '../features/promises/castings/all';\nexport { castings as strings } from '../features/strings/castings/all';\n",
      "exports": [
        {
          "name": "castings",
          "kind": "named",
          "text": "export { castings as arrays } from '../features/arrays/castings/all';",
          "moduleSpecifier": "../features/arrays/castings/all"
        },
        {
          "name": "castings",
          "kind": "named",
          "text": "export { castings as common } from '../features/common/castings/all';",
          "moduleSpecifier": "../features/common/castings/all"
        },
        {
          "name": "castings",
          "kind": "named",
          "text": "export { castings as numbers } from '../features/numbers/castings/all';",
          "moduleSpecifier": "../features/numbers/castings/all"
        },
        {
          "name": "castings",
          "kind": "named",
          "text": "export { castings as objects } from '../features/objects/castings/all';",
          "moduleSpecifier": "../features/objects/castings/all"
        },
        {
          "name": "castings",
          "kind": "named",
          "text": "export { castings as strings } from '../features/strings/castings/all';",
          "moduleSpecifier": "../features/strings/castings/all"
        }
      ]
    },
    "globals.types": {
      "imports": [],
      "relativePath": "globals/types.ts",
      "text": "export * from '../features/arrays/types';\nexport * from '../features/common/types';\nexport * from '../features/functions/types';\nexport * from '../features/numbers/types';\nexport * from '../features/objects/types';\nexport * from '../features/promises/types';\nexport * from '../features/strings/types';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '../features/arrays/types';",
          "moduleSpecifier": "../features/arrays/types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '../features/common/types';",
          "moduleSpecifier": "../features/common/types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '../features/functions/types';",
          "moduleSpecifier": "../features/functions/types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '../features/numbers/types';",
          "moduleSpecifier": "../features/numbers/types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '../features/objects/types';",
          "moduleSpecifier": "../features/objects/types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '../features/promises/types';",
          "moduleSpecifier": "../features/promises/types"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '../features/strings/types';",
          "moduleSpecifier": "../features/strings/types"
        }
      ]
    },
    "globals.typings": {
      "imports": [],
      "relativePath": "globals/typings.ts",
      "text": "export { typings as arrays } from '../features/arrays/typings/all';\nexport { typings as common } from '../features/common/typings/all';\n// export { typings as functions } from '../features/functions/typings/all';\nexport { typings as numbers } from '../features/numbers/typings/all';\nexport { typings as objects } from '../features/objects/typings/all';\n// export { typings as promises } from '../features/promises/typings/all';\nexport { typings as strings } from '../features/strings/typings/all';\n",
      "exports": [
        {
          "name": "typings",
          "kind": "named",
          "text": "export { typings as arrays } from '../features/arrays/typings/all';",
          "moduleSpecifier": "../features/arrays/typings/all"
        },
        {
          "name": "typings",
          "kind": "named",
          "text": "export { typings as common } from '../features/common/typings/all';",
          "moduleSpecifier": "../features/common/typings/all"
        },
        {
          "name": "typings",
          "kind": "named",
          "text": "export { typings as numbers } from '../features/numbers/typings/all';",
          "moduleSpecifier": "../features/numbers/typings/all"
        },
        {
          "name": "typings",
          "kind": "named",
          "text": "export { typings as objects } from '../features/objects/typings/all';",
          "moduleSpecifier": "../features/objects/typings/all"
        },
        {
          "name": "typings",
          "kind": "named",
          "text": "export { typings as strings } from '../features/strings/typings/all';",
          "moduleSpecifier": "../features/strings/typings/all"
        }
      ]
    },
    "globals.utils._unknown": {
      "imports": [],
      "relativePath": "globals/utils/_unknown.ts",
      "text": "/**\n * _unknown variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const _unknown = <T>(value?: unknown) => value as T;\n",
      "exports": []
    },
    "globals.utils.castFn": {
      "imports": [
        {
          "moduleSpecifier": "../types",
          "kind": "named",
          "namedImports": ["RuA"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./is/merge",
          "kind": "named",
          "namedImports": ["mergeIs"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "globals/utils/castFn.ts",
      "text": "import type { RuA } from '../types';\nimport { _unknown } from './_unknown';\nimport { expandFn } from './expandFn';\nimport { mergeIs } from './is/merge';\n\n/**\n * castFn variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const castFn = <T>() => {\n  const _out = <const Tr extends object = object>(extensions?: Tr) => {\n    const out = expandFn((arg: T) => arg, {\n      ...(extensions as Tr),\n      forceCast: (arg: unknown) => {\n        return _unknown<T>(arg);\n      },\n      dynamic: <U extends T>(arg: U) => {\n        return arg;\n      },\n    });\n    return out;\n  };\n  return _out;\n};\n\ncastFn.withValues = <T extends RuA>(...values: T) => {\n  const out = <const Tr extends object = object>(extensions?: Tr) =>\n    castFn<T[number]>()({\n      ...extensions,\n      is: mergeIs(...values),\n    });\n  return out;\n};\n\n    ",
      "exports": []
    },
    "globals.utils.expandFn": {
      "imports": [
        {
          "moduleSpecifier": "../../features/functions/types",
          "kind": "named",
          "namedImports": ["Fn", "FnBasic"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "globals/utils/expandFn.ts",
      "text": "import type { Fn, FnBasic } from '../../features/functions/types';\n\n/**\n * expandFn variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const expandFn = <\n  Main extends Fn,\n  const Tr extends object = object,\n>(\n  main: Main,\n  extensions?: Tr,\n): FnBasic<Main, Tr> => {\n  const out: any = main;\n\n  if (extensions) {\n    Object.assign(out, extensions);\n  }\n\n  return out;\n};\n\n    ",
      "exports": []
    },
    "globals.utils.identity": {
      "imports": [],
      "relativePath": "globals/utils/identity.ts",
      "text": "/**\n * identity variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const identity = <T>(value: T) => value;\n",
      "exports": []
    },
    "globals.utils.index": {
      "imports": [],
      "relativePath": "globals/utils/index.ts",
      "text": "export * from './_unknown';\nexport * from './castFn';\nexport * from './expandFn';\nexport * from './identity';\nexport * from './is';\nexport * from './typeFn';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './_unknown';",
          "moduleSpecifier": "./_unknown"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './castFn';",
          "moduleSpecifier": "./castFn"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './expandFn';",
          "moduleSpecifier": "./expandFn"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './identity';",
          "moduleSpecifier": "./identity"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './is';",
          "moduleSpecifier": "./is"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './typeFn';",
          "moduleSpecifier": "./typeFn"
        }
      ]
    },
    "globals.utils.is._default": {
      "imports": [
        {
          "moduleSpecifier": "../../../features/transform/types",
          "kind": "named",
          "namedImports": ["TransformS", "PrimitiveS"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "../../types",
          "kind": "named",
          "namedImports": ["Classe"],
          "isTypeOnly": true
        }
      ],
      "relativePath": "globals/utils/is/_default.ts",
      "text": "import type { TransformS, PrimitiveS } from '../../../features/transform/types';\nimport type { Classe } from '../../types';\n\n/**\n * isFn variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isFn = <const T>(check: T) => {\n  return (value?: unknown): value is T => {\n    return typeof value === check;\n  };\n};\n\n/**\n * isTypeFn variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isTypeFn = <T extends PrimitiveS | 'object'>(type: T) => {\n  return (value?: unknown): value is TransformS<T> => {\n    return typeof value === type;\n  };\n};\n\n/**\n * isInstance variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isInstance = <T extends Classe>(instance: T) => {\n  return (value?: unknown): value is T => {\n    return value instanceof instance;\n  };\n};\n\n    ",
      "exports": []
    },
    "globals.utils.is.index": {
      "imports": [],
      "relativePath": "globals/utils/is/index.ts",
      "text": "export * from './_default';\nexport * from './merge';\nexport * from './object';\nexport * from './primitive';\nexport * from './primitive.object';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './_default';",
          "moduleSpecifier": "./_default"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './merge';",
          "moduleSpecifier": "./merge"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './object';",
          "moduleSpecifier": "./object"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './primitive';",
          "moduleSpecifier": "./primitive"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './primitive.object';",
          "moduleSpecifier": "./primitive.object"
        }
      ]
    },
    "globals.utils.is.merge": {
      "imports": [
        {
          "moduleSpecifier": "../expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "globals/utils/is/merge.ts",
      "text": "import { expandFn } from '../expandFn';\n\n/**\n * mergeIs variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const mergeIs = expandFn(\n  <const T extends unknown[]>(...checks: T) => {\n    return (value?: unknown): value is T[number] => {\n      return checks.some(check => value === check);\n    };\n  },\n  {\n    type: <const T extends unknown[]>(...checks: T) => {\n      return (value?: unknown): value is T[number] => {\n        return checks.some(check => typeof value === check);\n      };\n    },\n  },\n);\n\n    ",
      "exports": []
    },
    "globals.utils.is.object": {
      "imports": [],
      "relativePath": "globals/utils/is/object.ts",
      "text": "/**\n * isPlainObject variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isPlainObject = (value?: any): value is object => {\n  return (\n    Object.prototype.toString.call(value) == '[object Object]' &&\n    value.constructor &&\n    value.constructor.name == 'Object'\n  );\n};\n",
      "exports": []
    },
    "globals.utils.is.primitive.object": {
      "imports": [
        {
          "moduleSpecifier": "../../types",
          "kind": "named",
          "namedImports": ["PrimitiveObject"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./object",
          "kind": "named",
          "namedImports": ["isPlainObject"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./primitive",
          "kind": "named",
          "namedImports": ["isPrimitive"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "globals/utils/is/primitive.object.ts",
      "text": "import type { PrimitiveObject } from '../../types';\nimport { isPlainObject } from './object';\nimport { isPrimitive } from './primitive';\n\n/**\n * isPrimitiveObject variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isPrimitiveObject = (\n  object?: unknown,\n): object is PrimitiveObject => {\n  const isObject = isPlainObject(object);\n  if (isObject) {\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        const element = (object as any)[key];\n        const isPrimitiveMap = isPrimitiveObject(element);\n        if (!isPrimitiveMap) return false;\n      }\n    }\n    return true;\n  }\n\n  const isArray = Array.isArray(object);\n  if (isArray) {\n    for (const item of object) {\n      const isPrimitiveMap = isPrimitiveObject(item);\n      if (!isPrimitiveMap) return false;\n    }\n    return true;\n  }\n\n  return isPrimitive(object);\n};\n\n    ",
      "exports": []
    },
    "globals.utils.is.primitive": {
      "imports": [
        {
          "moduleSpecifier": "../../../features/transform/constants",
          "kind": "named",
          "namedImports": ["PRIMITIVES"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "../../types",
          "kind": "named",
          "namedImports": ["Primitive"],
          "isTypeOnly": true
        },
        {
          "moduleSpecifier": "./merge",
          "kind": "named",
          "namedImports": ["mergeIs"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "globals/utils/is/primitive.ts",
      "text": "import { PRIMITIVES } from '../../../features/transform/constants';\nimport type { Primitive } from '../../types';\nimport { mergeIs } from './merge';\n\n/**\n * isPrimitive variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const isPrimitive = (value?: unknown): value is Primitive => {\n  const isType = mergeIs.type(...PRIMITIVES);\n  const isValue = mergeIs(null, undefined);\n  return isType(value) || isValue(value);\n};\n\n    ",
      "exports": []
    },
    "globals.utils.typeFn": {
      "imports": [
        {
          "moduleSpecifier": "./_unknown",
          "kind": "named",
          "namedImports": ["_unknown"],
          "isTypeOnly": false
        },
        {
          "moduleSpecifier": "./expandFn",
          "kind": "named",
          "namedImports": ["expandFn"],
          "isTypeOnly": false
        }
      ],
      "relativePath": "globals/utils/typeFn.ts",
      "text": "import { _unknown } from './_unknown';\nimport { expandFn } from './expandFn';\n\n/**\n * typeFn variable - Auto-generated expression\n * \n * ⚠️ WARNING: This expression is auto-generated and should not be modified.\n * Any manual changes will be overwritten during the next generation.\n * \n * @generated\n * @readonly\n * @author chlbri (bri_lvi@icloud.com)\n */\nexport const typeFn = <T = any>() => {\n  const _out = <Tr extends object = object>(extensions?: Tr) => {\n    const out = expandFn((_?: T) => _unknown<T>(), {\n      ...(extensions as Tr),\n      forceCast: (_?: unknown) => _unknown<T>(),\n      dynamic: <U extends T>(_?: U) => _unknown<U>(),\n      is: <U>(_?: U) => _unknown<U extends T ? true : false>(),\n      type: _unknown<T>(),\n    });\n\n    return out;\n  };\n\n  return _out;\n};\n\n    ",
      "exports": []
    },
    "index": {
      "imports": [],
      "relativePath": "index.ts",
      "text": "export * from '#utils/index';\nexport * from './features';\n",
      "exports": [
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from '#utils/index';",
          "moduleSpecifier": "#utils/index"
        },
        {
          "name": "*",
          "kind": "namespace",
          "text": "export * from './features';",
          "moduleSpecifier": "./features"
        }
      ]
    }
  }
}
